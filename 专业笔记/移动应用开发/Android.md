# Android

## 常用快捷键

1.  netstat -aon|findstr 5307
2.  taskkill /pid 进程号  /f



**shift+end** 快速从前往后选中一行(鼠标在行头)

**shift+home** 快速从后往前选中一行(鼠标在行尾)

**ctrl+x** 快速剪切一行(可以作为快速删除一行用)

**ctl+y** 快速删除一行

ctrl+/ 注释鼠标所在行或者注释所选中的内容

ctrl+shift+/ 多行代码注释

shift + tab 将选中代码整体向前移一个空格

tab 将选中代码整体向后移一个空格

alt + 按住鼠标左键+拖动鼠标 可以实现一系列重复操作

ctrl +alt + o 快速将类中的无用import清除

ctrl + b 快速进入某个方法内或者从方法内返回调用处

ctrl +alt + b 快速进入实现接口实现类内

ctrl + u 快速从接口实现内返回接口定义层



2、选择当前⾏

先按 END， 再按**SHIFT +HOME**

或先按 HOME，再按 **SHIFT+END**

3、选择当前光标处到⽂末的内容（或选择当前光标处到⽂⾸的内容）

**CTRL+SHIFT+END（或CTRL+SHIFT+HOME）**

4、选择光标处后⾯的⼀个字母（或者光标处前⾯的⼀个字母）SHIFT+右箭头（或者SHIFT+左箭头）

5、选择光标处后⾯的⼀个单词（或者前⾯的⼀个单词）

CTRL+SHIFT+右箭头（或者CTRL+SHIFT+左箭头）

## 发展历史

安卓是**<u>谷歌</u>**公司研发的***基于Linux内核开发的操作系统***，主要用于移动设备

**架构图**

![](pic\0.png)

Android几乎每年都要发布一个大版本，**<u>技术的更新迭代速度非常之快</u>**

![1](pic\1.png)

Android Studio是**基于IDEA**演变而来的，**比Eclipse更方便易用**

## SDK

***软件开发工具包，将源码编译为可执行App应用***

Software Development Kit，**软件开发工具包**

![](pic\2.png)

**adb工具**：android debug bridge ：PC 和 android os 之间的桥梁

**NDK**：java中使用c/c++，实现操作内存等高级功能

**Gradle script：工程编译配置文件**

**Gradle**：自动化构建工具

**build-gradle**：编译规则

Android **SDK 工具**会将您的代码连同任何数据和资源文件编译成一个 APK（*Android 软件包*），即带有 `.apk` 后缀的归档文件

## 四大组件

| Activities              | 描述UI，并且处理用户与机器屏幕的交互        |
| ----------------------- | ------------------------------------------- |
| **Services**            | 处理与应用程序关联的**后台操作**            |
| **Broadcast Receivers** | 处理Android操作**系统和应用程序之间的通信** |
| **Content Providers**   | **处理数据和数据库管理方面的问题**          |

### **Activity**

***拥有界面的单个屏幕***

例如，电子邮件应用可能有一个显示新电子邮件列表的 Activity、一个用于撰写电子邮件的 Activity 以及一个用于阅读电子邮件的 Activity。尽管这些 Activity 通过协作在电子邮件应用中形成一种紧密结合的用户体验，但**<u>每个 Activity 都独立于其他 Activity 而存在</u>**。因此，其他应用可以启动其中任何一个 Activity（如果电子邮件应用允许）。

例如，相机应用可以启动电子邮件应用内用于撰写新电子邮件的 Activity，以便用户共享图片。

Activity 有助于完成系统和应用程序之间的以下重要交互：

- 追踪用户当前关心的内容（屏幕上显示的内容），以确保系统继续运行托管 Activity 的进程。
- 了解先前使用的进程包含用户可能返回的内容（已停止的 Activity），从而更优先保留这些进程。
- 帮助应用处理终止其进程的情况，以便用户可以返回已恢复其先前状态的 Activity。
- 提供一种途径，让**应用实现彼此之间的用户流**，并让系统协调这些用户流。（此处最经典的示例是共享。）

### **Service** 

***使应用在后台保持运行状态***

**服务是一个通用入口点**，用于因各种原因**<u>*使应用在后台保持运行状态*</u>**。它是一种在后台运行的组件，用于执行长时间运行的操作或为远程进程执行作业。服务不提供界面。

例如，当用户使用其他应用时，服务可能会在后台播放音乐或通过网络获取数据，但这不会阻断用户与 Activity 的交互。诸如 Activity 等其他组件可以启动服务，使该服务运行或绑定到该服务，以便与其进行交互。事实上，有两种截然不同的语义服务可以告知系统如何管理应用：已启动服务会告知系统使其运行至工作完毕。此类工作可以是在后台同步一些数据，或者在用户离开应用后继续播放音乐。在后台同步数据或播放音乐也代表了两种不同类型的已启动服务，而这些服务可以修改系统处理它们的方式：

- 音乐播放是用户可直接感知的服务，因此，应用会向用户发送通知，表明其希望成为前台，从而告诉系统此消息；在此情况下，系统明白它应尽全力维持该服务进程运行，因为进程消失会令用户感到不快。
- 通常，用户不会意识到常规后台服务正处于运行状态，因此系统可以更自由地管理其进程。如果系统需要使用 RAM 来处理用户更迫切关注的内容，则其可能允许终止服务（然后在稍后的某个时刻重启服务）。

**绑定服务**之所以能运行，原因是某些其他应用（或系统）已表示希望使用该服务。从根本上讲，这是为另一个进程提供 API 的服务。因此，系统会知晓这些进程之间存在依赖关系，所以如果进程 A 绑定到进程 B 中的服务，系统便知道自己需使进程 B（及其服务）为进程 A 保持运行状态。此外，如果进程 A 是用户关心的内容，系统随即也知道将进程 B 视为用户关心的内容。由于存在灵活性（无论好坏），服务已成为非常有用的构建块，并且可实现各种高级系统概念。动态壁纸、通知侦听器、屏幕保护程序、输入方法、无障碍功能服务以及众多其他核心系统功能均可构建为在其运行时由应用实现、系统绑定的服务。

### **BroadcastReceiver**

***广播接收器***

借助广播接收器组件，系统能够在**<u>*常规用户流之外向应用传递事件*</u>**，从而允许应用响应系统范围内的广播通知。由于广播接收器是另一个明确定义的应用入口，因此**系统甚至可以向当前未运行的应用传递广播**。例如，应用可通过调度提醒来发布通知，以告知用户即将发生的事件。而且，通过将该提醒传递给应用的广播接收器，应用在提醒响起之前即无需继续运行。

许多广播均由系统发起，例如，**<u>*通知屏幕已关闭、电池电量不足或已拍摄照片的广播*</u>**。应用也可发起广播，例如，通知其他应用某些数据已下载至设备，并且可供其使用。尽管广播接收器不会显示界面，但其可以创建状态栏通知，在发生广播事件时提醒用户。但广播接收器更常见的用途只是作为通向其他组件的*通道*，旨在执行极少量的工作。例如，它可能会根据带 `JobScheduler` 的事件调度 `JobService` 来执行某项工作

**动态注册和静态注册**

动态注册的广播接收器可以自由地控制注册与注销，在灵活性方面有很大的优势，但是 它也存在着一个缺点，即必须要在程序启动之后才能接收到广播，因为注册的逻辑是写在 onCreate()方法中的。那么有没有什么办法可以让程序在未启动的情况下就能接收到广播 呢？这就需要使用静态注册的方式了。

### **ContentProvider**  

***管理一组共享的应用数据***

*内容提供程序*管理一组共享的应用数据，您可以**<u>将这些数据存储在文件系统、SQLite 数据库、网络中或者您的应用可访问的任何其他持久化存储位置</u>**。其他应用可通过内容提供程序查询或修改数据（如果内容提供程序允许）。

例如，Android 系统可提供管理用户联系人信息的内容提供程序。因此，任何拥有适当权限的应用均可查询内容提供程序（如 `ContactsContract.Data`），以读取和写入特定人员的相关信息。我们很容易将内容提供程序看作数据库上的抽象，因为其内置的大量 API 和支持时常适用于这一情况。但从系统设计的角度看，二者的核心目的不同。对系统而言，内容提供程序是应用的入口点，用于发布由 URI 架构识别的已命名数据项。因此，应用可以决定如何将其包含的数据映射到 URI 命名空间，进而将这些 URI 分发给其他实体。反之，这些实体也可使用分发的 URI 来访问数据。在管理应用的过程中，系统可以执行以下特殊操作：

- 分配 URI 无需应用保持运行状态，因此 URI 可在其所属的应用退出后继续保留。当系统必须从相应的 URI 检索应用数据时，系统只需确保所属应用仍处于运行状态。
- 这些 URI 还会提供重要的细粒度安全模型。例如，应用可将其所拥有图像的 URI 放到剪贴板上，但将其内容提供程序锁定，以便其他应用程序无法随意访问它。当第二个应用尝试访问剪贴板上的 URI 时，系统可允许该应用通过临时的 *URI 授权*来访问数据，这样便只能访问 URI 后面的数据，而非第二个应用中的其他任何内容。

内容提供程序也适用于读取和写入您的应用不共享的私有数据。

## **Intent**

***信使，异步消息***，对各个组件进行互相绑定

在四种组件类型中，有三种（Activity、服务和广播接收器）均通过异步消息 *Intent* 进行启动。Intent 会在运行时对各个组件进行互相绑定。您可以将 Intent 视为从其他组件（无论该组件是属于您的应用还是其他应用）请求操作的信使。

## AndroidManifest

在 Android 系统启动应用组件之前，**<u>系统必须通过读取应用的*清单*文件 (`AndroidManifest.xml`) 确认组件存在</u>**。您的应用必须在此文件中声明其所有组件，该文件必须位于应用项目目录的根目录中。

清单文件还有许多其他作用，如：

- 确定应用需要的任何用户权限，如互联网访问权限或对用户联系人的读取权限。
- 根据应用使用的 API，声明应用所需的最低 [API 级别](https://developer.android.google.cn/guide/topics/manifest/uses-sdk-element?hl=zh-cn#ApiLevels)。
- 声明应用使用或需要的硬件和软件功能，如相机、蓝牙服务或多点触摸屏幕。
- 声明应用需要链接的 API 库（Android 框架 API 除外），如 [Google 地图库](http://code.google.com/android/add-ons/google-apis/maps-overview.html?hl=zh-cn)。

## 完整App创建步骤

1. **layout目录下创建xml文件**
2. **创建与XML文件对应的java代码**
3. **在AndroidManifest中注册页面配置**

> **注意，Empty Views Activity 和 Empty Activity是不一样的，Empty Activity是默认Kotlin语言的**

![](pic\3.png)

**NDK**：高级工程师掌握的，在android开发中使用C/C++

安卓中使用的是自带的嵌入式数据库：**SQLite**，一般不用大型数据库

## 目录结构

每个项目至少一个模块，可以有多个，模块依附于项目

**<u>*一个模块对应一个App*</u>**

![](pic\4.png)

![](pic\5.png)

**矢量图是不会因为放缩而出现锯齿的**

代码编译成class -> 打包成APK文件

**Gradle**：项目自动化构建工具，可以做依赖，**打包成APK**，部署，发布，类似**java开发中的maven**

**proguard-rules.pro**：用于描述Java代码的混淆规则，把方法，函数等都替换为ABCD等，有利于安全性

> apk文件解压得到class，class再反编译就得到源码，就被破解了

![](pic\6.png)

![](pic\7.png)

安卓使用**XML标记描绘应用界面，用Java代码书写程序逻辑**

## 简单控件

单位尺寸

![](pic\8.png)

px：一个像素点。像素大小不固定，跟随屏幕大小和像素数量变化

分辨率：屏幕垂直和水平的像素数量

Dpi：像素密度，每英寸（2.54cm)距离有多少个像素点

dp：长度单位 ，最终会转换为px，具体效果根据设备的密度有关 

![](pic\10.png)

![](pic\11.png)

输出分辨率决定图像输出质量，描述的是设备输出图像时每英寸可产生的点数(dpi)，以dpi为单位。输出分辨率主要是指印刷需要的分辨率。