# C++介绍

## 特点

C++是**本地语言**，c++编译器为目标平台和目标架构生成机器码

编写C++程序时，需要**<u>*关心内存，高性能和优化等问题，不然用别的语言更好*</u>**

**C#和Java：<u>需要运行在虚拟机</u>上。代码首先被编译为一种中间语言，在目标平台上运行时，虚拟机在程序运行时再转换为机器码**

> 如果C++代码写的不好，甚至运行结果可能比虚拟机语言更慢。因为虚拟机语言会**倾向于<u>在运行时做系统优化</u>**。**如果追求<u>极致性能</u>的话，C++是个好的选择**

- **解释型：中间码**
- **编译型：二进制代码（机器码）**
- **混合型：例如Java，字节码**

> **解释型编译器：<u>并不直接产生二进制机器码</u>**，而是**<u>中间码</u>**，需要特定的软件先解释成二进制码才可运行
> 如Javascript脚本，这种方法灵活性强，**修改代码无需重新编译，但性能会损失**
> **编译型：**则**<u>直接产生二进制代码</u>**，无需软件支持，**靠硬件即可运行，这种方法速度快，性能好，但灵活性不足，每次修改都需要重新编译。**
> Java属于混合型，产生的不是中间码，而是**<u>字节码</u>**。java先将代码编译成字节码，再依靠java虚拟机模拟cpu运行程序，性能上有损失。java虚拟机不解释成机器码，而是模拟cpu运行，所以java称虚拟机。

**适用场景**

- 需要性能良好的代码
- 架构或平台的原生代码
- 游戏引擎

**工作原理：**

1. C++写代码
2. 被编译器编译
3. 编译器将**代码输出为<u>目标平台</u>的机器码（可执行的二进制文件）**

> **<u>C++可以直接访问控制硬件，可以完全控制CPU执行的每一条指令</u>**
>
> 只需要找到为目标平台输出机器码的编译器，C++可以运行在任何平台

**不同平台推荐的IDE和编译器**

- Windows：**VisualStudio**![](c++pic\6.png)
- Linux：**CodeLite（编译器）+ Cmake**
- MacOS：**XCode**（苹果开发的IDE）

## 工作原理

### 代码

**预处理语句**：#符号后面的都是，在实际编译发生之前就被处理。

> 例如**头文件**：将该文件所有内容拷贝到现在的文件内。

**main函数：程序的入口**，从这个函数开始执行代码。**<u>不一定需要返回值，系统会默认返回0</u>**

**重载运算符**：类似<<,>>。可以理解为**函数，例如print**![](c++pic\7.png)

### 主要流程

1. 编译器**<u>处理预处理语句</u>**，将**头文件内容全部包含到代码文件中**
2. 开始**编译**，将c++代码**<u>转化为机器码</u>**（ 只有cpp文件被编译，头文件不会被编译）。编译器为每个cpp源文件生成**.obj文件，object file（目标文件）**。VS快捷键**（ctrl + F7）**
3. **<u>链接器：链接所有obj文件合并成一个exe文件</u>**。

> **解决方案平台**：**编译代码的目标平台**。例如**X86，代表目标平台是32位的**。生成32位的windows应用程序
>
> **解决方案配置**：这些规则属性控制着**我们的项目文件将会如何被编译**。
>
> 例如在**Optimization属性**中可以看到**生成版本**为**Debug和Release**时的区别：**Release的是maximize speed，Debug是disabled。**
>
> **所以Debug会慢很多，因为<u>*优化都被关掉了，但好处是可以让我们调试代码*</u>。**
>
> **Debug**:通常称为**调试版本**，通过一系列编译选项的配合，编译的结果通常包含调试信息，而且不**做任何优化，以为开发人员提供强大的应用程序调试能力**。 
>
> **Release**:通常称为**发布版本**，是**为用户使用的**，因此不允许在发布版本上进行调试。
>
> **VS的error list没啥用，基本就是分析output窗口，找到error关键字然后抓取这部分信息展示出来。如果真的要细节错误信息,去看output window，<u>双击就能跳转到代码出错的位置。</u>**
>
> ![](c++pic\8.png)
>
> 如果要使用别的文件中的函数，一定要**声明后使用，这样编译器会知道别的文件包含这个函数。例子中，随后链接器会<u>找到正确的log函数定义</u>，并将其导入到main函数中的声明。如果没找到就会出现<u>*链接错误*</u>**
>
> ![](c++pic\9.png)

## Visual Studio设置

filter是以一种**<u>虚拟文件夹的形式</u>**工作的，并不存在在硬盘上，只是方便自己管理项目。

展示所有文件的才是显示真正的项目目录

![](c++pic\21.png)

VS2017和VS2019新建项目后可以有**<u>*将解决方案和项目放在同一目录下的选项*</u>**，不然项目结构会很奇怪

**输出目录和中间目录设置**

所有设置的路径都是**<u>相对项目根目录的相对路径</u>**

![](c++pic\22.png)

选择解决方案所在目录的原因：当有很多项目，比如生成dll文件的时候，或者生成被主应用需要的文件的时候，我们希望能把所有**生成好的二进制代码放在同一个文件夹中**。

![](c++pic\23.png)

### 调试与断点

附加调试器：**不用停止运行应用并调试的方法**，缺点是会降低程序性能

![](c++pic\164.png)

![](c++pic\165.png)

同时可以设置条件

![](c++pic\166.png)

### 静态分析

**PVS -Studio工具**

**在线编译器：wandbox.org**

## 编译器

![](c++pic\11.png)

**.i 文件**：预处理后文件，预处理器执行宏替换、条件编译以及包含指定的文件。

**.s 文件：** 汇编文件**，**由预处理得到的源代码文件，进行**机器翻译产出**。我们的老程序员前辈们以前大多都会学习汇编语言，但汇编语言写的源程序一般为大写的 .S 文件后缀，而且还会进行预处理、汇编等操作，而小写 .s文件后期阶段不再进行预处理操作，所以不能在内写预处理语句。

**.o 文件：**可重定位目标文件（机器码文件），由汇编文件经过汇编操作生成，该文件不可直接执行

**.out 文件**：二进制可执行目标文件（也是一个目标文件），由**机器码文件进一步链接生成**。这一步中，各种符号引用和符号定义转换成为可执行文件中的合适信息，通常是虚拟地址。

将源文件转换为目标文件

1. 预处理（可以选择生成**.i文件**查看），预处理器执行**<u>宏替换、条件编译以及包含指定的文件</u>**。
2. 记号化或解析，将代码整理为编译器能够**<u>真正理解和推理的格式（抽象语法树）</u>**，本质是我们代码的另一种表示
3. 将所有代码转化为常量数据或指令后，开始实际生成机器码（CPU将要执行的）

在VS中属性->预处理中，需要禁用预处理输出到文件，否则不会生成obj文件

**cpp文件是翻译单元**，只是**提供给编译器源代码的一种方式**。C++中**每个文件只会告诉编译器这是什么类型的文件，应该如何处理，例如.c,.cpp,.h**。不像Java，C++不关心文件。

**常用预处理语句**：**include，define，if，ifdef，pragma**

> **#include：打开对应文件，复制所有内容，然后粘贴到对应位置**
>
> **#define：实现文本替换**
>
> ![](c++pic\10.png)

## 链接器

主要焦点在于**<u>找到每个符号和函数，并把他们连接起来。</u>**

**<u>编译错误和链接错误是分开的</u>。**

- 如果错误是**C**开头，这个代表**编译错误**
- 如果错误是**LNK**开头，这个代表**链接错误**

> 例如，如果没有**设置入口点（大部分情况是main函数）**，编译是可以通过，但是链接时会报错
>
> **static关键字：链接只应该发生在该文件内部，标识这个函数只在这个翻译单元声明，它<u>*对其他obj文件都是不可见的*</u>。可以<u>避免符号重复定义之类的链接错误</u>**
>
> **inline关键字：把函数的函数体拿过来取代调用**

**最好的方法**：**<u>.h头文件只声明函数</u>**

- **头文件**用来写**类的声明** （包括类的成员的声明和方法声明）、**函数声明**、**＃define常数**等。
- **源文件**主要写实现头文件中已经声明的那些函数的具体代码。

## 变量

C++中不同的变量类型之间的唯一区别：**占用内存的大小**，可能根据编译器而不同。

用**sizeof**可以查看

例：![](c++pic\13.png)

程序输出为8

> **bool：1字节**
>
> **int ：4 字节byte**，范围约**-2.1b ~ 2.1b（第一位是符号位，数据范围2^31）**
>
> **unsigned int**:数据范围**0~4.2b(2^32)**
>
> **char: 1 yte** ，**char c = 65 和char c = “a” 运行效果一样**
>
> **short: 2 byte**
>
> **long: 4 byte**
>
> **float：4 byte**，注意使用时后面要加f
>
> **double: 8 byte**
>
> ![](c++pic\12.png)
>
> **long long: 8 byte**

## 函数

抽取重要功能，***<u>防止重复代码</u>***

> **只有main函数可以不用返回一个值，会自动假设返回0**

每次调用函数（并非**内联 inline**）时：**编译器生成调用指令**，为这个函数创建一整个**<u>stack frame（栈框架）</u>**，例如把参数，返回地址等push入栈，在内存中跳转

### 构造函数

Constructor

每当创建一个类的实例的时候调用，**命名必须和类名一样，用于初始化变量，<u>C++中必须手动初始化所有基础数据类型，不然就会被设置为之前保留在这块内存中的值</u>。**

> **函数重载**：相同的函数名有不同的参数

可以通过**private来隐藏构造函数**，不允许实例化

![](c++pic\43.png)

**<u>成员初始化列表</u>**的时候，要**保持上面声明的时候顺序一样**，因为最终编译器都会按照类成员的定义顺序进行初始化

这样写初始化可以**<u>让构造函数更简单和更有可读性，不然变量多的时候写在函数块里会很臃肿</u>**

> 如果不使用初始化列表，相当于创建一个新的实例，**造成性能浪费**，所以一定要使用

![](c++pic\72.png)

### 析构函数

Destructor

当一个对象被销毁时，析构函数会被调用，用于**释放内容或清理内存空间**

## 头文件

header file，不同于cpp类型编译文件

**作用：声明某些函数和类型，<u>告诉编译器表明这个函数存在</u>**

**#pragma once**：一种**新的预处理语句**，被称为**header guard（头文件保护符）**，**<u>防止把头文件多次include到一个翻译单元</u>**

include文件的两个**括号区别**：

- <>用于编译器去**所有include路径里搜索文件**
- “”用于**include文件存在于<u>该文件的相对位置（现在引号可以用于所有）</u>**

![](c++pic\15.png)

> **c标准库的头文件一般带有.h扩展名，而c++没有**
>
> 以前的一种头文件保护符做法：**#ifndef**
>
> ![](c++pic\14.png)

## Visual Studio Debug

**Breakpoint 和 Memory**

通过**设置断点可以来读取内存**

**断点**：**程序调试器会中断的一个点**，执行到这一行会**暂停该线程，来查看运行程序的内存**

黄色箭头表示**当前行准备执行<u>但还没有执行</u>**

- step into  **F11**：如果这行有函数，进入当前函数

- step over **F10**：转到当前函数的下一行代码

- step out **Shift + F11**：跳出当前函数，例如for循环等等

- F5：继续执行

- Autos，Locals ，Watch窗口：可以用来监控变量

- **内存视图**：查看整个运行程序的内存![](c++pic\16.png)

- 数据的实际值是以**16进制表示**的，右边是对应的ASCII码，**<u>&可以定位变量实际存储在程序内存的哪个位置</u>**![](c++pic\17.png)

- 每**两个数字代表一个字节**。CC,11001100,调试程序时，**未初始化的堆栈内存常被写入CC**。例如执行了int a =8；之后内存的变化：（注意int类型是**4个byte**）![](c++pic\18.png)

  ![19](c++pic\19.png)

## 条件语句

很多**<u>优化过的代码会尤其避免分支语句，避免比较，因为这会让代码变得很慢</u>**

可以利用**disassembly**来查看汇编代码，查看具体CPU里每个寄存器都存储了什么

![](c++pic\20.png)

**循环**

这样也是可以的，相当于while（True）![](c++pic\24.png)

while和do...while的区别是do...while循环体中的内容**至少会被执行一次**

**控制流语句**

- **break**：直接跳出循环
- **continue**：只能用于循环内部，如果还能进行迭代的话，**<u>直接进行下一次循环</u>，否则结束循环**
- **return**：直接退出函数 

## 指针

**内存**是应用程序最重要的部分，程序被载入内存，代码转化为指令。然后CPU访问并执行指令

**指针：只是一个<u>存储一个内存地址的整数</u>**

![](c++pic\25.png)

写入的时候需要**告诉编译器指针的类型，表示该写入多少字节的数据**

![](c++pic\26.png)

**new**：分配一个**<u>连续的8字节的内存</u>**，并返回一个**指向这块内存的<u>*开始地址*</u>**

**memset**：用指定的数据填充一块内存

![](c++pic\27.png)

**delete**：删除这片数据

![](c++pic\28.png)

### 引用

reference，和**指针功能类似**，一种**<u>基于指针的语法糖</u>**，使得代码更加易读写

> 在C++编程语言中，引用是一种简单的引用数据类型，**其功能不如从C继承的指针类型，但更安全**
>
> 指针并不需要初始化操作，即它可以不指向任何对象，也正因如此，**指针的安全性不如引用**

引用给某个变量一个**别名**，**<u>本身不是一个新的变量，而是必须引用一个已存在的变量</u>**

![](c++pic\35.png)

注意：

- **<u>初始化引用</u>**：声明一个引用时，**必须将实际变量赋值给他**
- 一个引用只能用于一个变量

![](c++pic\32.png)

**引用传递参数**

传递变量的地址，**<u>*通过内存地址完成读写*</u>**

> **引用本质是指针的语法糖，引用能做的指针都能做，只是简化代码，更有可读性**

运用指针时：

![](c++pic\30.png)

使用引用：

![](c++pic\31.png)

引用和指针的区别

> "指针指向一块内存，它的内容是**所指内存的地址**；而**引用则是某块内存的别名**，也是占内存空间的，引用不改变指向"
>
> **<u>指针和引用最终在编译中的实现是一样的，但是引用的形式大大方便了使用也更安全</u>**

1. **引用不可以为空，但指针可以为空**
2. 引用不可以改变指向，对一个对象"至死不渝"；但是指针可以改变指向，而指向其它对象。  
3. 引用的的大小是其**指向的对象的大小**，因为引用仅仅是一个别名；**指针的大小与平台有关，在32位平台下指针大小为4个字节**
4. 引用比指针使用起来形式上更漂亮，使用引用指向的内容时可以之间用引用变量名，而不像指针一样要使用*；定义引用的时候也不用像指针一样使用&取址。  
5. 引用比指针更安全。由于不存在空引用，并且引用一旦被初始化为指向一个对象，它就不能被改变为另一个对象的引用，因此引用很安全。对于指针来说，它可以随时指向别的对象，并且可以不被初始化，或为NULL，所以不安全。

### 函数指针

来自于C的特性，将一个函数赋值给变量

获取函数指针，用&就可以取到地址。编译时，每个函数都被编译成**CPU指令**

![](c++pic\135.png)

![](c++pic\136.png)

实例：

**void(*函数名)(参数)**

![](c++pic\137.png)

使用**lambda表达式**

![](c++pic\138.png)

## 类和结构体

**<u>面向对象程序设计</u>**：**需要<u>类和对象</u>等概念，是非常流行的编程思想**

比如**JAVA,C#**只适合面向对象

C++不同之处在于不仅支持**<u>面向对象编程，还支持面向过程，基于对象，泛型</u>**这四种

默认情况下，类中的**访问控制都是私有的（只有类的内部函数才能访问这些变量）**

**public**：公有属性关键字，表示在类外任何地方可以访问这些变量

结构体和类相似，区别是**<u>类的成员默认是私有的，而结构体默认是公有的</u>**

**C++想要维持与C的兼容性，所以保留了struct**。

代码实际使用时候的：**<u>没有正确或错误，看程序员的编程风格</u>**

- **struct**：plain old data，例如数学中向量只是表示两个浮点数的**<u>，单纯的数据结构，不需要实现复杂的功能</u>**
- ![](c++pic\33.png)
- **class**：可以实现**继承**或其他复杂功能，例如**玩家，地图**等等

**实现类最好的方法是先看需要哪些功能，再回到类中补充**

![](c++pic\34.png)

## getter 和 setter方法

> 就是属性封装后**对外提供的获取和修改对应属性值**的访问方式

##  static

静态方法：建议**<u>定义全局变量或全局函数的时候都带上static关键字</u>，不然linker会跨编译单元进行链接，导致奇怪的bug**

**类或者结构体外**：static在链接阶段是局部的,**只对定义它的编译单元cpp文件可见**

linker**不会去这个编译单元外找这个变量的定义，对别的编译单元不可见**

**类或者结构体内**：静态变量被这个类的**<u>所有实例共享</u>**，所以就算实例化很多次，**静态变量只有一个实例**

静态变量或函数就最好**用命名空间来调用，而不是实例**，例如下例的**Entity::**

**<u>*静态方法不能访问非静态变量*，因为静态方法没有获得当前的类实例（this指针），所以根本不知道类里的成员变量</u>**

![](c++pic\37.png)

![](c++pic\36.png)

**局部作用域中使用static来声明变量**

static的作用不止在函数中可以使用，if语句等也可以使用

**核心：当你想要在函数内使用全局变量，但又不希望别的地方使用或修改它，那就可以使用static关键字**

例：输出：1 2 3 4 5

![](c++pic\38.png)

**单例类：**

static让变量**生命周期变成永久**

**只有第一次调用Get会创建一个类实例，然后之后所有调用都会返回这个实例**

![](c++pic\39.png)

## enums

枚举，enumeration的缩写，基本上就是**一些值的集合**，主要目的是**<u>增加程序的可读性</u>，适合使用数字集合的地方**

- **枚举是常量的集合**
- **枚举对象在任一时刻只能有一个常量值**

> **枚举：希望可以定义一种数据结构，使其值只能是枚举中所有值中的某一个值，从而把这些数据结合起来了**
>
> **默认赋值是0，1，2...，也可以手动赋值**

例：

1. **enum** week{ Mon, Tues, Wed, Thurs, Fri, Sat, Sun };
2. **enum** week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun };
3. **enum** week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } a = Mon, b = Wed, c = Sat;

需要注意：**枚举和宏其实非常类似：宏在预处理阶段将名字替换成对应的值，枚举在编译阶段将名字替换成对应的值**。我们可以将枚举理解为编译阶段的宏。

```c++
#include <stdio.h>
int main(){
    enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } day;
    scanf("%d", &day);
    switch(day){
        case Mon: puts("Monday"); break;
        case Tues: puts("Tuesday"); break;
        case Wed: puts("Wednesday"); break;
        case Thurs: puts("Thursday"); break;
        case Fri: puts("Friday"); break;
        case Sat: puts("Saturday"); break;
        case Sun: puts("Sunday"); break;
        default: puts("Error!");
    }
    return 0;
}
对于上面的代码，在编译的某个时刻会变成类似下面的样子：
#include <stdio.h>
int main(){
    enum week{ Mon = 1, Tues, Wed, Thurs, Fri, Sat, Sun } day;
    scanf("%d", &day);
    switch(day){
        case 1: puts("Monday"); break;
        case 2: puts("Tuesday"); break;
        case 3: puts("Wednesday"); break;
        case 4: puts("Thursday"); break;
        case 5: puts("Friday"); break;
        case 6: puts("Saturday"); break;
        case 7: puts("Sunday"); break;
        default: puts("Error!");
    }
    return 0;
}
```

例：

![](c++pic\40.png)

简化代码：

![](c++pic\41.png)

![](c++pic\42.png)

## 继承

**类的继承**是**面向对象编程**中的一个**基本概念**

继承：使得类之间有了相互关联的层级关系，使得**通用功能积累**

> 一般是把**通用功能放在父类**，然后从它创建出派生类
>
> 父类中非私有的成员，派生类都可以访问

## 多态

使用一个单一的符号来表示多个不同的类型

## 虚函数

在函数前加上**virtual**关键字

目的：让我们可以**在子类中重写方法**

> **<u>如果想要重写一个函数，那么必须在基类中把原函数设置为虚函数</u>**
>
> C++11新标准中允许给**被重写的函数用"override"关键字标记**，但不是必须的，可以**<u>帮助Debug和代码可读性</u>**

![](c++pic\45.png)

例如如果A是B的父类，在**A类中新建一个虚函数，则可以在B类中重写这个函数去完成别的功能**

![](c++pic\44.png)

例：**如果不使用虚函数，会输出两遍Entity类中的GetName函数，而不是派生类中的Player重写的GetName函数**

虚函数引入了一种**动态分配**的东西，一般通过**虚表（vtable）**来实现编译

**虚表**：包含了类中所有虚函数的映射的列表，这样就可以在运行时正确找到被重写的函数

### 纯虚函数

和其他语言中的**抽象方法和接口**类似，<u>**允许我们定义一个基类中没有实现的函数，然后强制子类去实现**</u>

这也是**接口**：一个**<u>只包含未实现方法并作为模板的类</u>**

使用时只能**实例化实现了所有纯虚函数的类**

方法：

![](c++pic\46.png)

## **可见性**

面向对象中的一个概念，指一个**类中的成员或者方法是否可见（谁能调用，访问）**

三个基础的**访问修饰符**：

- **private**:只有**自己类和friend类**可以访问私有成员，**<u>派生类不能访问</u>**
- **protected**：**自己类和派生类**可以访问这些成员
- **public**：任何人都可以访问

可见性目的：与程序性能无关，但可以**<u>确保别人不会调用他们不应该访问的代码。同时有助于理解和代码可读性</u>**

## 数组

一些元素的集合，他们在内存中是连续的。实际上是一个指针指向这片内存地址。如果访问不属于这片内存的区域，会触发**内存访问冲突（memory access violation）**，debug模式下会报错，但是release模式下可能不会报错。

> for循环中，为了**性能考虑，一般用<而不是<=比较，不然每次需要多做一个等于的比较**

处理指针时，只要在指针上加数字即可，它会**<u>自动根据数据类型来计算实际的字节数</u>**

例：

![](c++pic\47.png)

- 普通创建数组在**栈**上的，跳出作用域后就会被销毁
- 可以用new关键则来动态分配数组，创建在**堆上**，但是生存周期是不同的，，会存活到程序销毁

**内存间接寻址**

用**new**的方法的话**地址里存的是另一个地址，那个地址指向我们的实际的数组**

> **C++11没法显式获得数组长度，但也有办法获取数组长度，如果数组在栈上**
>
> 如果用**new的话就没办法获得数组长度**
>
> **C++必须自己维护数组长度**
>
> ![](c++pic\50.png)
>
> ![](c++pic\51.png)

例：

![](c++pic\49.png)

### array

包含array库后就可以使用，**array包含额外开销，但会提供边界检查，还提供 size（）查看数组长度等功能**

![](c++pic\52.png)

**vector、list、array容器区别**

**1.vector数据结构** 

vector用数组实现，拥有一段**连续的内存空间**，并且起始地址不变。 因此能**高效的进行访问**，时间复杂度为o(1)，因为使用下标访问; 但因为内存空间是连续的，所以在进行插入和删除操作时，会造成内存块的拷贝，时间复杂度为o(n)。 另外，当数组中内存空间不够时，会重新申请一块内存空间并进行内存拷贝。  

**2.list数据结构**

 list是由**双向链表**实现的，因此**内存空间是不连续的**。 只能通过指针访问数据，所以list的随机访问效率不高，时间复杂度为o(n); 但由于链表的特点，**<u>能高效地进行插入和删除</u>**。 

 **3.array数据结构**  

元素在栈上分配内存，**大小固定不变，内存连续，可随机存取**。和vector相比是**对静态数组的封装，使用下标访问元素数据**。array**不可以动态插入**,因为第一次分配空间就固定了，使用时：注意数组越界操作问题.

### std::array

标准数组类，C++标准库模板库

基本用法：

![](c++pic\134.png)

相比普通数组的优势：

- **不用维护数组的大小**，用**size()**就可以知道
- 很多其他功能，比如排序，迭代器遍历
- 增加了一层调试，可以边界检查等

### 动态数组

标准模板库，本质是一个充满**<u>容器类型</u>**的库，可以把它模板成任何东西

**vector**是**动态数组**，内存中连续，可以调整大小

> 很多工作室和团队会自己基于标准库重新创建自己的容器库，使得更好的性能
>
> **指针类型的vector**也有用，比如string类型的话每次内存会重新分配，复制黏粘都需要大量的时间

**遍历方式**

![](c++pic\106.png)

用第二种方式是会将每个数值复制到for循环中，为了避免复制，最好用**引用传递**

改进：

![](c++pic\107.png)

#### 优化vector

**工作原理**：当push back 新的元素的时候，如果vector**容量不够就需要分配新的内存**，然后将内存中**旧的位置的所有内容复制到内存中的新位置**，然后删除旧的位置

**<u>如果容量用完，就需要分配新的内存，这是代码运行慢的原因之一</u>**

所以处理向量的时候，如何**避免复制就很重要**

C++11中如果push_back**优先选择移动构造函数，然后才是复制构造函数**

**优化**

- 合适的位置调用构造函数，不然main函数构造然后移入vector浪费性能
- 最好预先给定一个容量，避免后续多次调整，可以使用**reserve函数**![](c++pic\108.png)
- **emplace_back**： 永远可以替换push_back，功能一样。不是实际传递一个vector存储的对象，而是**传递构造函数的参数列表**，不会调用复制构造，![](c++pic\109.png)

> **可以<u>避免创建临时对象，造成性能损失</u>**
>
> **因为 emplace_back 接受可变参数，因此直接传入到 emplace_back 函数中进行构造**
>
> **`emplace_back` 只会调用一次构造函数，不会在原地构造完之后再次调用复制构造函数。**

### 多维数组

二维数组：

![](c++pic\155.png)

三维数组：
![](c++pic\156.png)

**内存泄漏的情况**

![](c++pic\157.png)

正确的释放方式：

![](c++pic\158.png)

将**所要访问的数据在内存中连续存放是很好的优化方式，因为有更多的缓存命中，计算机会执行更快**

例：优化后的二维数组分配

![](c++pic\159.png)

### 自己实现标准库中的Array

***vector是动态，可以调整大小，但他们分配在堆上，会无故地拖慢程序性能***

> 对于在栈上分配的数组，编译的时候需要指定数组大小，即需要静态分配
>
> 但是实际上可以通过指针来在栈上模拟动态分配

![](c++pic\203.png)

**constexpr关键字**：表示在编译时可以被评估的

模拟简单的array数组：没有iterator

![](c++pic\204.png)

## **排序**

升序排序：返回true的话，a在b之前

![](c++pic\160.png)



## 字符串

C++**默认处理字符的方式是ASCII字符**，**英文字符char占一个字节8bit，一共有256种可能，足够英文字符使用**

> ASCII码可以扩展为：
>
> **utf-8，utf-16，utf-32**，其他语言**<u>如日语中文一个字符可以大于一个字节</u>**

字符串就是**字符数组**，C中是char*，C++中有string

例：

**空终止符会被设置为0**

![](c++pic\53.png)

如果没有0终止符，输出也不知道数组边界，便会**输出乱码**。原因是这些乱码由于越界内存会被设置为**CC（内存栈守卫）导致的。**

![](c++pic\55.png)

![](c++pic\54.png)

**解决方法**：

![](c++pic\56.png)

![57](c++pic\57.png)

C++**标准库**中有一个类string，是**<u>模板类basic_string的模板特化（模板类实例化）</u>**

> **string头文件会重载操作符<<，运行我们把字符串传到输出流中**

![](c++pic\58.png)

因为C++中**const char[]类型，不能作“+”**，必须分开来写或**显式调用（因为标准库中重载了“+”操作）**

![](c++pic\59.png)

![](c++pic\64.png)

string作为**只读参数**的时候，最好用**常量引用**（不会拷贝一份，承诺不会改变）

> **因为复制字符串意味着我们必须在堆上动态地创建全新的char数组来存储文本，是很慢的**

![](c++pic\60.png)

修改后：

![](c++pic\61.png)

```c++
s1+s2          // 返回 s1 和 s2 拼接后的结果。加号两边至少有一个 string 对象，不能都是字面值
s1 == s2       // 如果 s1 和 s2 中的元素完全相等则它们相等，区分大小写
s1 != s2
<, <=, >, >=   // 利用字符的字典序进行比较，区分大小写   
string s1;    // 初始化一个空字符串
string s2 = s1;   // 初始化s2，并用s1初始化
string s3(s2);    // 作用同上
string s4 = "hello world";   // 用 "hello world" 初始化 s4，除了最后的空字符外其他都拷贝到s4中
string s5("hello world");    // 作用同上
string s6(6,'a');  // 初始化s6为：aaaaaa
string s7(s6, 3);  // s7 是从 s6 的下标 3 开始的字符拷贝
string s8(s6, pos, len);  // s7 是从 s6 的下标 pos 开始的 len 个字符的拷贝

isalnum(c)  // 当是字母或数字时为真
isalpha(c)  // 当是字母时为真
isdigit(c)  // 当是数字是为真
islower(c)  // 当是小写字母时为真
isupper(c)  // 当是大写字母时为真
isspace(c)  // 当是空白（空格、回车、换行、制表符等）时为真
isxdigit(c) // 当是16进制数字是为真
ispunct(c)  // 当是标点符号时为真（即c不是 控制字符、数字、字母、可打印空白 中的一种）
isprint(c)  // 当时可打印字符时为真（即c是空格或具有可见形式）
isgraph(c)  // 当不是空格但可打印时为真
iscntrl(c)  // 当是控制字符时为真
tolower(c)  // 若c是大写字母，转换为小写输出，否则原样输出
toupper(c)  // 类似上面的
```

**常用功能汇总**

![](c++pic\62.png)

char*实际上**<u>指向一个不允许编辑的常量数据，是放在只读内存中的。不允许修改</u>**

> 所以c++11开始例如clang编译器只允许**const char***的定义字面量
>
> char，char16和char32分别对应**utf8，utf16和utf32，1，2和4个字节**

![](c++pic\63.png)

string前面加**“R”**可以**忽略转义字符**，例：

![](c++pic\65.png)

### 使用C++完成C风格的String

注意需要手动添加空终结字符

![](c++pic\99.png)

### 字符串视图  string_view

***用观察一个已有的字符串，取代创建一个新的字符串***

***string_view：理解成进入现有内存的小视图，而不是分配一个新的字符串，这样可以减少分配string的数量***，本质就是一个const char指针，指向现有的字符串

![](c++pic\180.png)

优化：1次分配

![](c++pic\181.png)

更优化：0次分配 

![182](c++pic\182.png)

函数传参也可以用：

![](c++pic\183.png)

## const

 其实是一个**“假的”**关键字，因为它实际上在生成代码的时候并没有做什么，是**针对开发人员写代码的强制规则**

const就是让你承诺**<u>这个变量是不会再修改的</u>**,但也可以不遵守，帮助**代码可读性**

**1.指针**

**const int*** ：可以**修改指针指向的地址，但不能修改地址存的内容**

> 另一种写法是：**int const***，**关键只看*和const的位置**

**int* const：正好相反，可以改变指针指向的内容，但不能指向别的地址**

![](c++pic\66.png)

![](c++pic\67.png)

**2.const放在方法名后面（只在类中有用）**

**<u>如果没有修改类或不应该修改类，总是把方法设置为const</u>**

表示这个方法**是一个<u>*只读*</u>的方法，只能从类中读取数据，不能修改数据**，像**一种承诺**不会修改这个类

![](c++pic\68.png)

### mutable

即使在const方法中也可以修改变量**

![](c++pic\69.png)

例如：**计数器**

![](c++pic\70.png)

**mutable也可以用于Lambda表达式**

例：**x变量还是通过值传递，其实等价于由创建了一个局部变量y，然后y++，但是代码会干净很多**

![](c++pic\71.png)

## 三目运算符

**if语句的语法糖**，用？：来代替if-else语句

因为**高级编译器<u>返回值优化</u>的特性**，所以三目运算符**没有构造中间值，提高了性能**（普通if-else语句创建新变量然后覆盖）

> **编译器优化 RVO：调用过程中，通常是拷贝构造函数，将 this 指针全都替换对象的地址，这就叫做返回值优化**

例：

![](c++pic\73.png)

**三目运算符还可以嵌套**

但是不建议嵌套，因为**影响代码的美观，但确实更简洁**

![](c++pic\74.png)

##  对象

**类的实例化**。应用程序主要会把内存分为：**堆**和**栈**

C++中我们**可以选择对象创建在堆还是栈，他们有不同的功能性差异**

> **栈对象**：有一个**<u>自动的生存周期</u>**，由他声明地方的**作用域决定，超出作用域内存就会被销毁**
>
> **堆对象**：会**一直存在**，直到自己手动释放内存

![](c++pic\75.png)

## 内存空间

应用程序启动后，操作系统会**<u>将整个程序加载到内存，并分配一大堆物理RAM</u>**

> **RAM对应的是电脑的内存**，负责程序的运行以及数据交换。
>
> **ROM对应的是电脑中的硬盘**，是一块存储空间，可以存储各种各样的文件，包括视频，照片，音乐，软件等。

栈和堆的**<u>实际位置都是在内存中，用来存储运行程序时所需的数据</u>**

- 相同：本质都是要求C++给我们**分配一些内存空间**
- 不同：**分配内存原理不一样**

![](c++pic\122.png)

 调试模式下，会**添加安全守卫（safety guard）在变量周围（通常是cc）用于确保变量不会溢出**

### 栈

用栈分配数组的时候，**栈指针移动（所以栈分配会很快）**所需的字节长度，在内存空间中**位置是连续的**

> 同理，**释放的时候就是弹出内存，指针回到作用域开始的地方**

**初始化对象最快和最受管控**的方式

> 因为性能原因，在**堆上分配要比在栈上分配花费更长时间**，而且最后需要手动去释放分配的内存

![](c++pic\76.png)

> **跳出作用域后，栈结构被销毁，栈上所有内存，在栈上创建的所有变量都会消失**
>
> 作用域可以是**函数，if，花括号**等等

![](c++pic\78.png)

### 堆

- 如果**希望在作用域生存期之外**也能存活
- 如果这个**对象太大，或需要创建很多对象**，**没有足够的内存空间**来进行分配，因为**栈通常都很小，取决于平台和编译器**
- 会维护一个**空闲列表（free list）**，当找到大小满足的内存块，请求内存并返回指针，作很多记录，包括**分配的内存大小等**，所以堆分配的方式会慢一点，**实际的访问（CPU和缓存miss）**通常影响并不大

#### new

**<u>new关键字是重点</u>**，是一个**操作符**。主要目的是在**堆上分配内存**

赋值对象时只**复制了内存地址**，最后需要**手动delete，否则就会出现内存泄漏，即程序运行结束后，内存仍然被程序占用，导致系统资源浪费。**

> 内存泄漏主要原因：
>
> - 程序循环new创建出来的对象**没有及时的delete掉，导致了内存的泄露**；
> - delete掉一个void*类型的指针，导致**没有调用到对象的析构函数**，析构的所有清理工作都没有去执行从而导致内存的泄露；

![](c++pic\79.png)

new之后，会**去空闲列表（维护着空闲字节的地址）找，在内存中找出足够大的连续的空闲内存块，返回一个指向那个内存地址的指针**。

调用new关键字，会调**<u>用底层的C函数：malloc，传入一个size，然后返回一个void指针</u>**

> **所以调用delete是关键，不然空闲列表中这片地址就不会被标记为空闲,浪费内存空间**

**区别**：第一种方式会调用构造函数，第二种仅仅分配了内存

![](c++pic\80.png)

## implicit 和 explicit

**implicit**

C++**允许隐式地转换两种类型<u>一次</u>，可以不用cast**

例：将字符串和int隐式地转换为了Entity

![](c++pic\81.png)

![](c++pic\82.png)

**explicit**

**唯一功能：禁用隐式转换**

![](c++pic\83.png)

所有**<u>用隐式转换的构造函数都会失效</u>**

![](c++pic\84.png)

## 操作符和操作符重载

操作符重载：本质是一个函数，允许你在程序中定义或者更改一个操作符的行为，Java不允许

> 应该尽可能少地使用操作符重载，只在他非常有意义的时候使用

Java中用法：

![](c++pic\85.png)

![](c++pic\86.png)

**重载：**

![](c++pic\87.png)

![](c++pic\88.png)

![](c++pic\91.png)

对比：

重载后**代码更加简洁可读**

![](c++pic\89.png)

输出流的操作符<<也重载：

![](c++pic\90.png)

## this关键字

C++通过this可以直接访问成员函数，函数内部this是指向这个函数所属的当前对象实例的指针

**delete this后，任何成员数据都会失败，因为内存已经被释放掉了** 

![](c++pic\92.png)

## 生存周期

C++每次进入一个作用域时，push栈帧，**跳出作用域后就销毁**

**堆的话会一直存活直到程序结束或者手动删除**

局部作用域创建数组然后返回指针就是个**经典的错误**

## 智能指针

**智能指针**就是new后**自动化delete过程**，不用程序员手动销毁，**<u>甚至不用自己调用new</u>**

使用智能指针时，它会调用new并分配内存，**<u>根据智能指针的类型，在某个时间释放内存</u>**

> 作用：你**<u>不需要明确的调用删除或显式管理内存</u>**，智能指针能**自动化管理内存**
>
> **unique_ptr开销很低**，可以尽量多用
>
> **shared_ptr用于需要在对象间共享，额外的开销是引用计数系统**

例：

**ScopedPtr对象是在栈上分配的，e被销毁时，调用析构函数就会删除Entity指针**

![](c++pic\93.png)

![](c++pic\94.png)

### unique_ptr

唯一指针，也叫**作用域指针**，超出范围就会被销毁，**<u>不能复制唯一指针</u>**

必须**显式调用构造函数**

> **作用：异常安全，如果构造函数发生异常，不会有一个没有引用的悬空指针，造成内存泄漏**

![](c++pic\95.png)

### shared_ptr

**共享指针**，实现方式取决于编译器，通过**引用计数**的工作方式,它会**<u>跟踪指针的引用数，直到0的时候把它的内存释放</u>**

创建一个共享指针，然后创建另一个指针复制他

> 不用第二行new的方式来构建，因为共享指针必须分配另一个称为**<u>控制块的内存块（存储引用计数）</u>**
>
> 如果先创建实体再传递靠构造函数，就是两次分配

![](c++pic\96.png)

**当复制他的所有共享指针对象消失后，这个最底层的指针删除**

##### 弱指针

**weak_ptr**：共享指针分配给弱指针时，可以**给予他共享实体的价值**，就像复制共享实体**但并不增加引用计数**

当你不想拥有这个实体，只想存储对他们的引用，**可以询问它指针是否还有效**

## 复制

变量存在不同的内存地址

![](c++pic\97.png)

指针赋值的时候**是让他们同时指向同一片内存地址**

![](c++pic\98.png)

### 浅拷贝

![](c++pic\99.png)

### 深拷贝

完整地复制对象，使用**复制构造函数**

1. **在堆上分配内存**
2. **复制所有内容**
3. **释放内存**

![](c++pic\100.png)

### 引用传递

最好总是通过常量引用传递对象

**<u>不需要复制，只需要参考现有的对象</u>**

![](c++pic\101.png)

## Arrow Operator

等价于**指针解引用后再调用**

![](c++pic\103.png)

![](c++pic\104.png)

获取内存中某个值的**偏移量**

![](c++pic\105.png)

> 

## 使用库（静态链接）

- 专业大型项目，最好新建一个项目，该项目包含依赖库的源代码，然后将其编译为静态或动态库
- 如果是**小项目，链接二进制文件**会更快更容易

选择32位二进制文件或64位二进制文件是**根据目标应用程序**

- **x86，也就是win32程序就是32位**
- **如果是64位应用程序就用64位二进制文件**

![](c++pic\110.png)

**c++库**的典型组织是两部分：**includes和library**，**包含目录和库目录**

- **includes：一堆头文件，可以实际使用预构建的二进制文件中的函数**
- **library：一些预先构建的二进制文件**

**静态链接**：库会直接放入可执行文件中，发生在编译时

> **静态链接在技术上更快，因为编译器和连接器会进行优化**

![](c++pic\111.png)

因为是**编译器指定的包含路径**，所以可以用**引号或者尖括号**

> 如果是项目解决方案内部一起编译，用引号；如果是外部的库用尖括号，**<u>个人喜好没有对错</u>**

![](c++pic\112.png)

指定库目录后，还需要只能相对那个库目录的库文件

![](c++pic\113.png)

![](c++pic\114.png)

甚至可以去掉头文件，但是需要加上extern "C"，保证链接到一个C语言建立的库，防止**name-mangling**

![](c++pic\115.png)

## 动态链接

**动态链接库 dll**：在程序运行时被链接，即动态链接是**链接发生在运行时，即<u>启动可执行文件后才会被加载</u>**

区别：静态链接是发生在编译时，**<u>编译一个静态库，然后将其链接到可执行文件</u>**，可以允许更多优化

例：

确保在一个可访问的地方有dll文件，可以在整个应用程序中设置库搜索位置，**可执行文件的目录下是一种自动搜索路径**

![](c++pic\116.png)

## 创建多个项目和使用库

如果是一个大型项目，**<u>使用代码创建模块或库可以多次重用这些代码</u>**

> **SolutionDir就是包含sln文件的目录**

![](c++pic\117.png)

## **模板**

**templates**，类似其他语言里就是**“泛型”**,功能更强大，会**<u>简化代码，但有时编写的复杂会难以debug</u>**

使用场景：**日志系统**

允许你定义一个可以根据你的用途进行编译的模板，**<u>让编译器按照规则帮我们写代码</u>**

功能：比如想用一个函数，大部分是相同的但是**接受的参数不同**，这个时候就可以用模板

例：

![](c++pic\118.png)

**typename：模板参数**

![](c++pic\119.png)

其中Pirnt函数只是一个模板，实际调用前是不存在的，**<u>只有我们调用这个函数的时候才会被实际创造出来</u>**

**模板也可以用于类**

![](c++pic\120.png)

希望编译时能**<u>指定类型也可以</u>**，用**<u>2个模板参数，type和 size</u>**

![](c++pic\121.png)

有点像**<u>元编程，针对编译器编译的时候进行编程</u>**

## **STL**

**C++ STL（标准模板库）是一套功能强大的 C++ 模板类，提供了通用的模板类和函数，这些模板类和函数可以实现多种流行和常用的算法和数据结构，如向量、链表、队列、栈。**

## 宏

**在debug模式下输出，release版本为空**

![](c++pic\123.png)

![](c++pic\124.png)

更好的办法：

![](c++pic\125.png)

反斜用法：

![](c++pic\126.png)

## auto

**自动推导出所需要的变量类型**，有点像**弱类型语言**的特性

![](c++pic\127.png)

用法：

1.修改**函数的api**后，客户端代码不用跟着修改，但也可能破坏依赖特定类型的代码，**可读性也会变差**

![](c++pic\128.png)

2.复杂的变量类型**迭代器**

![](c++pic\129.png)

![130](c++pic\130.png)

不使用**引用返回值**，将会复制变量

![](c++pic\131.png)

![132](c++pic\132.png)

> **using 或 typedef**也可以，但是还是较为复杂
>
> ![](c++pic\133.png)

## lambda表达式

[(243条消息) C++中的Lambda表达式详解_c++ lambda_StudyWinter的博客-CSDN博客](https://blog.csdn.net/Zhouzi_heng/article/details/124960737)

本质：定义一种叫做**匿名函数的方式，是创建一次性的函数**

lambda不需要通过函数定义就可以定义函数，***只要有函数指针，就可以使用lambda***

![](c++pic\139.png)

[]：capture，捕获区域，用来**传递变量**

**[=]：值传入，拷贝变量后传入**

**[&]：引用传入**

![](c++pic\140.png)

![141](c++pic\141.png)

![](c++pic\142.png)

加入mutable关键字后就可以修改传入的参数

![](c++pic\143.png)

可以用于***find_if，筛选出符合条件的迭代器***

![](c++pic\144.png)

## 命名空间

***在一个作用域内用来避免命名冲突***

> 建议：最好在一个小的作用域中使用namespace

C中为了同时使用不同的库，防止重名，很多C语言的库不得不**将库的名字放在前面**，比如glfwInit。

而C++中则采用命名空间来***解决这个重名问题***

![](c++pic\145.png)

![146](c++pic\146.png)

 **using namespace apple**：从命名空间apple中导入所有东西

![](c++pic\147.png)

命名空间也可以设置别名：

![](c++pic\148.png)

## 线程

![](c++pic\149.png)

thread.join等一下当前线程完成再继续

例：

![](c++pic\150.png)

多线程时为了防止CPU占用率太高，一般会加入sleep来

![](c++pic\151.png)

get_id：获取线程的id

![](c++pic\152.png)

## 计时器

![](c++pic\153.png)

![](c++pic\154.png)

## 类型裁剪

C++是强类型语言，有自己的类型系统。表现出c++真正能操作内存的能力

![](c++pic\161.png)

![](c++pic\162.png)

## 联合体（Union）

　共用体，也叫联合体，在一个“联合”内可以定义多种不同的数据类型， 一个被说明为该“联合”类型的变量中，允许装入该“联合”所定义的任何一种数据，这些数据共享同一段内存，以达到节省空间的目的。**union变量所占用的内存长度等于最长的成员的内存长度。**

![](c++pic\163.png)

### 互斥赋值

在任意时刻，联合中只能有一个数据成员可以有值。当给联合中某个成员赋值之后，该联合中的其它成员就变成未定义状态了。

```c++

union Token{
   char cval;
   int ival;
   double dval;
};

Token token;
token.cval = 'a';
token.ival = 1;
token.dval = 2.5;
```

union的一个用法就是可以用来***测试CPU是大端模式还是小端模式***

```c++
![167](C:\CHARLES\Personal\专业笔记\Leetcode\c++pic\167.png)#include <iostream>
using namespace std;

void checkCPU()
{
    union MyUnion{
        int a;
        char c;
    }test;
    test.a = 1;
    if (test.c == 1)
        cout << "little endian" <<endl;
    else cout << "big endian" <<endl;
}

int main()
{
    checkCPU();
    return 0;
}
```

> 由于union里面的东西***共享内存***，所以不能定义静态、引用类型的变量。由于在union里也不允许存放带有构造函数、析构函数和复制构造函数等的类的对象，但是可以存放对应的类对象指针。编译器无法保证类的构造函数和析构函数得到正确的调用，由此，就可能出现内存泄漏。所以，在C++中使用union时，尽量保持C语言中使用union的风格，尽量不要让union带有对象。

## 预编译头文件

***对于项目来说都应该使用，可以大大改善编译的速度***

***可以把一些自己不会修改的头文件放入，如标准库，windows库等***，避免每次包含进cpp文件中都要重新编译他们

例：

![](c++pic\167.png)

## dynamic_cast

***用来验证多态类型是否为某一特定类型，如果强制转换有效，将返回想要的指针，否则返回NULL指针***

![](c++pic\168.png)

![](c++pic\169.png)

## 基准测试

***测试新技术和旧技术相比性能如何***

![170](c++pic\170.png)

![](c++pic\171.png)

![](c++pic\172.png)

**计时器用法：**

![](c++pic\173.png)

比较shared 指针和unique指针

![](c++pic\174.png)

结果：

![](c++pic\175.png)

### 可视化 benchmark

timer类：

![](c++pic\184.png)

![](c++pic\185.png)

**google chrome自带一些分析工具和开发工具，针对网络应用或者网页**

**chrome Tracing**：chrome://tracing , 可以让我们**<u>可视化我们的分析和堆栈跟踪视图</u>**

> **插桩（Instrumentation）：注入我们自己的代码并进行分析**

![](c++pic\186.png)

![187](c++pic\187.png)

![188](c++pic\188.png)

![189](c++pic\189.png)



## 结构化绑定

***仅在C++17之后的版本生效***，当你***不想转换成元组的形式，可以用结构化绑定来使代码更加干净整洁***

![](c++pic\176.png)

## optional

![](c++pic\177.png)

## variant

***Union更高效和节省空间，variant更类型安全，不会造成未定义行为***

![](c++pic\178.png)

更好的：

![](c++pic\179.png)

## 单例模式

**<u>根本来说单例的行为就像命名空间</u>**

***一种设计模式 ，只想要一个实例。当我们想要拥有应用于某种全局数据集的功能，且我们只是想要重复使用时，单例是非常有用的***

比如**随机数生成器，渲染器**

> **意图：**保证一个类仅有一个实例，并提供一个访问它的全局访问点。
>
> **主要解决：**一个全局使用的类频繁地创建与销毁。
>
> **何时使用：**当您想控制实例数目，节省系统资源的时候。
>
> **如何解决：**判断系统是否已经有这个单例，如果有则返回，如果没有则创建。
>
> **关键代码：**构造函数是私有的。
>
> **应用实例：**
>
> - 一个班级只有一个班主任。
> - Windows 是多进程多线程的，在操作一个文件的时候，就不可避免地出现多个进程或线程同时操作一个文件的现象，所以所有文件的处理必须通过唯一的实例来进行。
> - **一些设备管理器常常设计为单例模式**，比如一个电脑有两台打印机，在输出的时候就要处理不能两台打印机打印同一个文件。
>
> **优点：**
>
> - 在内存里只有一个实例，***减少了内存的开销，尤其是频繁的创建和销毁实例（比如管理学院首页页面缓存）。***
> - 避免对资源的多重占用（比如写文件操作）。
>
> **缺点：**没有接口，不能继承，与单一职责原则冲突，**一个类应该只关心内部逻辑，而不关心外面怎么样来实例化。**
>
> **使用场景：**
>
> - 要求生产唯一序列号。
> - WEB 中的计数器，不用每次刷新都在数据库里加一次，用单例先缓存起来。
> - 创建的一个对象需要消耗的资源过多，比如 I/O 与数据库的连接等。
>
> **注意事项：**getInstance() 方法中需要使用同步锁 synchronized (Singleton.class) 防止多线程同时进入造成 instance 被多次实例化。

例：

拷贝函数设置为了delete

核心：**<u>Get函数，只会在第一次使用的时候创建一个单独的实例</u>**，一旦有了这个单例，可以简单地写任何数量的非静态方法，并通过Get函数访问他们

![](c++pic\190.png)

![191](c++pic\191.png)

## 跟踪内存分配

重载new关键字

![](c++pic\192.png)

![](c++pic\193.png)

## 左右值

- **左值：某种存储支持的变量**
- **右值：临时值**

&&：右值引用，只接受右值

&：左值引用，只能接受左值，除非是const

> ***const 左值引用可以接受左值或者右值***

![](c++pic\194.png)

## 移动语义

***利用指针赋值，取代复制构造函数。对于繁重的对象，如果只是移动对象而不是复制（深拷贝）它，那么程序性能会提高很多***

> 相当于浅拷贝，只是重新连接了指针。不是分配一个新的数据块，然后把所有的东西复制进去，实际上是指针指向老的字符串的同一数据块，然后把旧的字符串设为空状态

![](c++pic\195.png)

![](c++pic\196.png)

![](c++pic\197.png)

### std::move

想要***将一个已经存在的对象转换为临时对象，表示可以从这个特定的变量中窃取资源***，然后使用移动构造函数或者移动赋值操作符就可以从哪个变量中获取资源并进行移动

![](c++pic\198.png)

更好的做法，用std::move， 在编译的时候会找出输入的类型：

![](c++pic\199.png)

### 移动赋值运算符

在赋值操作符中，需要***确保当前对象不等于另一个对象***

![](c++pic\200.png)

例：

![](c++pic\201.png)

结果：

![](c++pic\202.png)

# Leetcode题解

# 简单

## 1.两数之和

```c++
class Solution {
public:
    vector<int> twoSum(vector<int>& nums, int target) {
      unordered_map<int, int> hashtable;
        for (int i = 0; i < nums.size(); ++i) {
            auto it = hashtable.find(target - nums[i]);		//核心
            if (it != hashtable.end()) {    //反之，则返回一个指向容器中最后一个键值对之后位置的迭代器（如果 end() 方法返回的迭代器）。
                return {it->second, i};
            }
            hashtable[nums[i]] = i;
        }
        return {};
    }
};

无序关联容器unordered_map
unordered_map是一个将key和value关联起来的容器，它可以高效的根据单个key值查找对应的value。
key值应该是唯一的，key和value的数据类型可以不相同。
unordered_map存储元素时是没有顺序的，只是根据key的哈希值，将元素存在指定位置，所以根据key查找单个value时非常高效，平均可以在常数时间内完成。
unordered_map查询单个key的时候效率比map高，但是要查询某一范围内的key值时比map效率低。
可以使用[]操作符来访问key值对应的value值。
```

![](c++pic\0.png)

## 9.回文数

```c++
常规解法
bool isPalindrome(int x) {
    if (x < 0) return false; // 负数不是回文数
    long long temp = x, reverse = 0;
    while (temp != 0) {
        reverse = reverse * 10 + temp % 10;
        temp /= 10;
    }
    return x == reverse;
 }

class Solution {
public:
    bool isPalindrome(int x) {
        if (x < 0) return false;
        if (x < 10) return true;
        string org = to_string(x);		//to_string函数
        string t = org;
        reverse(t.begin(),t.end());
        return org == t;
    }
};

//reverse函数
vector<int> a;

reverse(a.begin(), a.end());	//可以翻转vector容器

string s = "abcdefg";
reverse(s.begin(), s.end());

char s[] = "abcdefg";		//翻转字符数组
int N = sizeof(s) / sizeof(s[0]);
reverse(s, s + N - 1);


int s[] = { 1,2,3,4,5,6,7,8,9 };	//翻转数组
reverse(s, s + 9);

//reverse_copy 将结果拷贝到另外一个容器中，不影响原容器的内容。
string first, second;
first = "123456789";
second.resize(first.size());
reverse_copy(first.begin(), first.end(), second.begin());

```

## 13.罗马数字转整数

```c++
class Solution {
    map<char,int> Map={			//map<char，int>
    {'I',1},
    {'V',5},
    {'X',10},
    {'L',50},
    {'C',100},
    {'D', 500},
    {'M', 1000}
};
public:
    int romanToInt(string s) {
        int ans = 0;
        int cnt = s.size();
        if(cnt == 0){ return 0;}
        for(int i =0; i < cnt -1; i++)
        {
            if(Map[s[i]] < Map[s[i+1]])
            {
                ans -= Map[s[i]];
            }
            else
            {
                ans += Map[s[i]];
            }
        }
        return ans + Map[s[cnt-1]];
    }
};
```

## 14.最长公共前缀

```c++
 string longestCommonPrefix(vector<string>& strs) {
        sort(strs.begin(), strs.end());
        string &s1 = strs.front();
        string &s2 = strs.back();
        int size = (int) min(s1.size(), s2.size());
        int len;
        for (len = 0; len < size; len++) {
            if (s1[len] != s2[len]) 
            {
                break;
            }
        }
        return {s1.begin(), s1.begin() + len};
     // return s1.substr(0,len);
    }
```

## 20.有效的括号

```c++
  unordered_map<char,int> m{{'(',1},{'[',2},{'{',3},
                                {')',4},{']',5},{'}',6}};
        stack<char> st;
        bool istrue=true;
        for(char c:s){
            int flag=m[c];
            if(flag>=1&&flag<=3) 
                st.push(c);
            else if(!st.empty()&&m[st.top()]==flag-3) 
                st.pop();
            else {istrue=false;break;}
        }
        if(!st.empty()) istrue=false;
   return istrue;


unordered_map<char, char> dict{{'(', ')'}, {'{', '}'}, {'[', ']'}};
        stack<char> st;
        for (auto i : s) {		//遍历s中的每个字符
            if (dict.find(i) != dict.end()) {
                st.push(i);
            }
            else {
                if (st.empty())
                    return false;
                if (dict[st.top()] != i)
                    return false;
                st.pop();
            }
        }
        return st.empty();		//容器为空返回true，否则返回false
```

## 21.合并有序链表

```c++
//链表经典题目
ListNode* mergeTwoLists(ListNode* list1, ListNode* list2) {
        ListNode* dummyHead = new ListNode();
        ListNode* cur = dummyHead;
        while (list1 || list2) {
            if (!list2 || list1 && list1->val < list2->val) {
                cur->next = new ListNode(list1->val);
                list1 = list1->next;
            }
            else {
                cur->next = new ListNode(list2->val);
                list2 = list2->next;
            }
            cur = cur->next;
        }
        return dummyHead->next;
    }
```

## 26.删除有序数组中的重复项

```c++

//双指针
已经检索过的部分对后续搜索没有影响
一个指针i=0指向最开始的位置，遍历nums中所有数，若当前数与i位置相同则跳过，若不相同则放置与++i位置。
 int removeDuplicates(vector<int>& nums) {
        int i = 0;
        for (int x : nums) 
        {
            if (x != nums[i]) nums[++i] = x;
        }
        return i + 1; 
 }

//unique函数
unique函数可以删除有序数组中的重复元素
int removeDuplicates(vector<int>& nums) {
        return unique(nums.begin(),nums.end())-nums.begin();
}

```

## 27.移除元素

```c++
 int removeElement(vector<int>& nums, int val) {
        int i = 0;
        for (int x : nums) 
        {
            if (x != val)
            {
                nums[i++] = x;
            }
            
        }
        return i; 
}
```

## 35.搜索插入位置

```c++
// 二分查找
int searchInsert(vector<int>& nums, int target) {
        int n = nums.size();
        int left = 0, right = n - 1, ans = n;
        while (left <= right) {
            int mid = ((right - left) >> 1) + left;			//求中点的方法
            if (target <= nums[mid]) 
            {
                ans = mid;							//因为是升序插入，所以ans放在位置尽量大的地方
                right = mid - 1;
            } 
            else 
            {
                left = mid + 1;
            }
        }
        return ans;
}
```

## 58.最后一个单词的长度

```c++
    int lengthOfLastWord(string s) {
        int n = s.size();
        int index(n-1),ans(0);
        while(s[index] == ' ') {index--;}   		//去掉末尾的连续空格
        while(index>=0 && s[index]!= ' ')
        {
            ans++;
            index--;
        }
        return ans;
  }
```

## 66.加一

```c++
  vector<int> plusOne(vector<int>& digits) {
        vector<int> ans;
        int carry = 1;
        reverse(digits.begin(),digits.end());   		//reverse翻转vector
        for(int i:digits)
        {
            int num = i + carry;
            ans.insert(ans.end(), num%10);			//vector插入操作
            carry = num/10;
        }
        if(carry == 1) 
        {
            ans.insert(ans.end(),1);
        }
        reverse(ans.begin(),ans.end());
        return ans;
  }
```

## 67.二进制求和

```c++
//int转化为二进制数组的形式
vector<int> Transform(int n)
{
    vector<int>m;
    for(int i =31; i>=0; i--)
    {
        m.push_back( ( (n>>i) & 1) );//与1做位操作，前面位数均为0
    }
    return m;
}

//常规解法
 string addBinary(string a, string b) {
        string res;
        int carry = 0;
        int i = a.size() - 1;
        int j = b.size() - 1;
        while (i >= 0 || j >= 0 || carry != 0) {
            int digitA = i >= 0 ? a[i] - '0' : 0;
            int digitB = j >= 0 ? b[j] - '0' : 0;
            int sum = digitA + digitB + carry;
            carry = sum >= 2 ? 1 : 0;
            sum = sum >= 2 ? sum - 2 : sum;
            res += to_string(sum);
            i --;
            j --;
        }
        reverse(res.begin(), res.end());
        return res;
 }

//
n & 1 可以获取整数n的最低二进制位
```

## 69.X的平方根

![](c++pic\1.png)

![](c++pic\2.png)

```c++
//二分查找
int mySqrt(int x) {
        if(x<=1){ return x; }
        int left = 0, right = x/2;
        while(left <= right) { // 闭区间
            int mid = left + (right - left) / 2; // 这里还可以使用位运算代替除法运算
            if((long) mid * mid <= x) left = mid + 1; // 可能的整型溢出问题处理方式3：向上转型 long
            else right = mid - 1;
        }
        return left - 1; // 正平方根永远会在 left 左边一个的位置，所以写成 left - 1 即可
}

//牛顿迭代法
//双根迭代
 public int mySqrt(int x) {
        double xi = x, xj = (xi + x / xi) / 2;
        while(Math.abs(xi - xj) > 1e-7) { // 双根 xi 和 xj 同时向左移动不断逼近正平方根
            xi = xj;
            xj = (xi + x / xi) / 2;
        }
        return (int) xj; // 返回 xi 也可以，二者之间的差距已经足够小，返回 xj 的话逻辑上更严谨
    }

//单根迭代
 public int mySqrt(int x) {
        long xi = x;
        while((long) xi * xi > x) xi = (xi + x / xi) / 2; // 固定 x 不动，单根 xi 不断向左移动逼近正平方根
        return (int) xi;
    }
```

## 70.爬楼梯

```c++
//动态规划
int climbStairs(int n) {
       int* dp=new int[n+5];
       dp[1]=1;
       dp[2]=2;
       for(int i=3;i<=n;i++)
       {
           dp[i]=dp[i-1]+dp[i-2];
       }
       return dp[n];
    }
```

## 83.删除排序链表中的重复元素

```c++
//双指针
ListNode* deleteDuplicates(ListNode* head) {
        if (head == nullptr)
            return nullptr;
        ListNode* l = head, *r = l->next;
        while (r) {
            if (l->val != r->val) {
                l->next = r;
                l = l->next;
            }
            r = r->next;
        }
        l->next = r; // 这一句很关键，当重复元素在末尾时r会一致走到空此时可以解决，一般情况也不会造成影响
        return head;
}
```

## 88.合并两个有序数组

```c++
//巧用sort函数
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
    for (int i = 0; i < n; i++)
    {
    	nums1[m + i] = nums2[i];
    }
    sort(nums1.begin(), nums1.end());
}

//双指针
void merge(vector<int>& nums1, int m, vector<int>& nums2, int n) {
        int p1(0), p2(0);
        int cur;
        int ans[m + n];
        while(p1<m || p2<n){
            if (p2 == n){ cur = nums1[p1++];} 
            else if(p1 == m){ cur = nums2[p2++];}
            else if(nums1[p1] < nums2[p2]){
                cur = nums1[p1++];
            }
            else{
                cur = nums2[p2++];
            }
            ans[p1 + p2 - 1] = cur;
        }
        for(int i=0;i<m+n;i++)
        {
            nums1[i]=ans[i];
        }
    }
```

## 94.二叉树的中序遍历

```c++
二叉树的中序遍历：按照访问左子树——根节点——右子树的方式遍历这棵树，而在访问左子树或者右子树的时候我们按照同样的方式遍历，直到遍历完整棵树。
//递归
void inorder(TreeNode* root, vector<int>& res) {
        if (!root) {
            return;
        }
        inorder(root->left, res);
        res.push_back(root->val);
        inorder(root->right, res);
    }
vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        inorder(root, res);
        return res;
    }

//迭代法
vector<int> inorderTraversal(TreeNode* root) {
        vector<int> res;
        stack<TreeNode*> stk;
        while (root != nullptr || !stk.empty()) {
            while (root != nullptr) {
                stk.push(root);
                root = root->left;
            }
            root = stk.top();
            stk.pop();
            res.push_back(root->val);
            root = root->right;
        }
        return res;
}
```

## 100.相同的树

```c++
//DFS
bool isSameTree(TreeNode* p, TreeNode* q) {
        if (p == nullptr) return q == nullptr;
        return q != nullptr && p->val == q->val && isSameTree(p->left, q->left) && isSameTree(p->right, q->right);
}
```

## 101.对称二叉树

```c++
//递归
bool isSameTree(TreeNode *p, TreeNode *q) {
        if (p == nullptr || q == nullptr)
            return p == q;
        return p->val == q->val && isSameTree(p->left, q->right) && isSameTree(p->right, q->left);
    }

public:
    bool isSymmetric(TreeNode *root) {
        return isSameTree(root->left, root->right);
    }
```

## 104.二叉树的最大深度

```c++
int maxDepth(TreeNode* root) {
        if(root == nullptr) return 0;
        return max(maxDepth(root->left),maxDepth(root->right)) + 1;
    }
```

## 108.将有序数组转换为二叉搜索树

```c++
//中序遍历
class Solution {
public:
    TreeNode* sortedArrayToBST(vector<int>& nums) {
        return helper(nums, 0, nums.size() - 1);
    }

    TreeNode* helper(vector<int>& nums, int left, int right) {
        if (left > right) {
            return nullptr;
        }

        // 总是选择中间位置右边的数字作为根节点
        int mid = (left + right + 1) >> 1;

        TreeNode* root = new TreeNode(nums[mid]);
        root->left = helper(nums, left, mid - 1);
        root->right = helper(nums, mid + 1, right);
        return root;
    }
};
```

## 110.平衡二叉树

```c++
 int height(TreeNode* root) {
        if (root == NULL) 
        {
            return 0;
        } 
        else 
        {
            return max(height(root->left), height(root->right)) + 1;
        }
    }

    bool isBalanced(TreeNode* root) {
        if (root == NULL) 
        {
            return true;
        } 
        else
        {
            return abs(height(root->left) - height(root->right)) <= 1 && isBalanced(root->left) && isBalanced(root->right);
        }
    }
```

## 111.二叉树的最小深度

```c++
//解题思路：直接递归，根节点左子树右子树为空时，递归取max。
class Solution {
int minDepth(TreeNode* root) {
        if(root==nullptr)
        	return 0;
        if(root->left == nullptr||root->right == nullptr)
            return 1+max(minDepth(root->left),minDepth(root->right));
        else
            return 1+min(minDepth(root->left),minDepth(root->right));

    }
```

## 112.路径总和

```c++
bool hasPathSum(TreeNode* root, int targetSum) {
        if(root == nullptr) { return false;}
        if(root->left == nullptr && root ->right == nullptr)
        {
            return root->val == targetSum;
        }
        return hasPathSum(root->left,targetSum - root->val) || hasPathSum(root->right,targetSum - root->val);
}
```

## 118.杨辉三角

```c++
 vector<vector<int>> generate(int numRows) {
        vector<vector<int>> rowNums;
        vector<int> tp;
        for(int i =0;i < numRows;i++)
        {
            tp.clear();
            for(int j =0;j <= i;j++)
            {
                if(j == 0) tp.push_back(1);
                else if(j == i) tp.push_back(1);
                else{
                     tp.push_back((rowNums[i-1][j-1] + rowNums[i-1][j]));
                }
            }
            rowNums.push_back(tp);            
        }
        return rowNums;
    }
```

## 119. 杨辉三角 II

![](c++pic\3.png)

```c++
//递推
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<vector<int>> C(rowIndex + 1);
        for (int i = 0; i <= rowIndex; ++i) {
            C[i].resize(i + 1);
            C[i][0] = C[i][i] = 1;
            for (int j = 1; j < i; ++j) {
                C[i][j] = C[i - 1][j - 1] + C[i - 1][j];
            }
        }
        return C[rowIndex];
    }
};

//优化   滚动数组，节省空间
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> pre, cur;
        for (int i = 0; i <= rowIndex; ++i) {
            cur.resize(i + 1);
            cur[0] = cur[i] = 1;
            for (int j = 1; j < i; ++j) {
                cur[j] = pre[j - 1] + pre[j];
            }
            pre = cur;
        }
        return pre;
    }
};

//数学公式推导
class Solution {
public:
    vector<int> getRow(int rowIndex) {
        vector<int> row(rowIndex + 1);
        row[0] = 1;
        for (int i = 1; i <= rowIndex; ++i) {
            row[i] = 1LL * row[i - 1] * (rowIndex - i + 1) / i;
        }
        return row;
    }
};

```

## 121.买卖股票的最佳时机

```c++
//一直维护数组中最低值
int maxProfit(vector<int>& prices) {
        int minPrice = INT_MAX;
        int ans = 0;
        for(int price:prices)
        {
            if(price < minPrice) minPrice = price;
            if(price - minPrice > ans)
            {
                ans = price - minPrice;
            }
        }
        return ans;
}
```

## 125.验证回文串

```c++
//c++的几个字符处理重要内置函数
islower(char c) 是否为小写字母
isupper(char c) 是否为大写字母
isdigit(char c) 是否为数字
isalpha(char c) 是否为字母
isalnum(char c) 是否为字母或者数字
toupper(char c) 字母小转大
tolower(char c) 字母大转小
    
class Solution {
public:
    bool isPalindrome(string s) {
        string tmp;
        for (auto c : s) {
            if (islower(c) || isdigit(c))  tmp += c;
            else if (isupper(c)) tmp += (c + 32);	//小写转大写  也可以用tolower(c)
        }
        int i = 0, j = tmp.size() - 1;
        while (i < j) 
        {
            if (tmp[i] != tmp[j]) return false;
            i++;
            j--;
        }
        return true;
    }
};
```

## 136.只出现一次的数字

```c++
//异或位运算
int singleNumber(vector<int>& nums) {
        int res = nums[0];
        for( int i = 1;i < nums.size();i++ )
            res ^= nums[i];
        return res;
}

//哈希表   用unordered_map
int singleNumber(vector<int>& nums) {
        unordered_map<int,int>mp;
        for( auto num : nums ){
            ++mp[num];
        }
        for( auto [mpp,cnt] : mp ){
            if( cnt == 1 )  return mpp;
        }
        return 0;
}
```

## 141.环形链表

```c++
//快慢指针
bool hasCycle(ListNode *head) {
        ListNode *slow = head, *fast = head;
        while (fast && fast->next) {
            slow = slow->next;
            fast = fast->next->next;
            if (fast == slow)
                return true;
        }
        return false;
    }
};

//哈希表
bool hasCycle(ListNode *head) {
        unordered_map<ListNode*,int> tp;
        while(head)
        {
            if(tp[head]) return true;
            tp[head] += 1;
            head = head->next;
        }
        return false;
}
```

# 中等

## 2.两数相加

```c++
//链表经典结构
ListNode* addTwoNumbers(ListNode* l1, ListNode* l2) {
        // res = new ListNode((l1->val + l2->val) % 10);
        ListNode* pre = new ListNode(0);
        ListNode* now = pre;
        int carry = 0;
        while(l1||l2)
        {
            int i1 = l1==nullptr?0:l1->val;
            int i2 = l2==nullptr?0:l2->val;
            int sum = i1 + i2 + carry;
            now->next = new ListNode(sum%10);
            carry = sum/10;
            if(l1){ l1 = l1->next;}
            if(l2){ l2 = l2->next;}
            now = now->next;
        }
        if(carry == 1){ now->next = new ListNode(1);}
        return pre->next;
```

## 3.无重复字符的最长子串

```c++
//滑动窗口
unordered_set 容器，可直译为“无序 set 容器”。即 unordered_set 容器和 set 容器很像，唯一的区别就在于 set 容器会自行对存储的数据进行排序，而 unordered_set 容器不会
int lengthOfLongestSubstring(string s) {
        // 哈希集合，记录每个字符是否出现过
        unordered_set<char> occ;
        int n = s.size();
        // 右指针，初始值为 -1，相当于我们在字符串的左边界的左侧，还没有开始移动
        int rk = -1, ans = 0;
        // 枚举左指针的位置，初始值隐性地表示为 -1
        for (int i = 0; i < n; ++i) {
            if (i != 0) {
                // 左指针向右移动一格，移除一个字符
                occ.erase(s[i - 1]);
            }
            while (rk + 1 < n && !occ.count(s[rk + 1])) {
                // 不断地移动右指针
                occ.insert(s[rk + 1]);
                ++rk;
            }
            // 第 i 到 rk 个字符是一个极长的无重复字符子串
            ans = max(ans, rk - i + 1);
        }
        return ans;
    }

//情况2
int lengthOfLongestSubstring(string s)
    {
        //s[start,end) 前面包含 后面不包含
        int start(0), end(0), length(0), result(0);
        int sSize = int(s.size());
        while (end < sSize)
        {
            char tmpChar = s[end];
            for (int index = start; index < end; index++)
            {
                if (tmpChar == s[index])
                {
                    start = index + 1;
                    length = end - start;
                    break;
                }
            }
            end++;
            length++;
            result = max(result, length);
        }
        return result;
    }
```

## 5.最长回文子串

```c++
//动态规划
string longestPalindrome(string s) {
        int n=s.length();
        bool dp[n+1][n+1];
        for(int i=0;i<n;i++)
            dp[i][i]=true;
        int left=0;
        int right=0;
        for(int j=1;j<n;j++)
        {
            for(int i=0;i<j;i++)
            {
                if((j-i<3 || dp[i+1][j-1]==true)&&s[i]==s[j])
                {
                    dp[i][j]=true;
                    if(right-left<j-i)
                    {
                        right=j;
                        left=i;
                    }
                }
                else
                    dp[i][j]=false;
            }
        }
        return s.substr(left,right-left+1);
    }

//中心扩散法
回文中心的两侧互为镜像。因此，回文可以从他的中心展开，并且只有 2n-1 个这样的中心（一个元素为中心的情况有 n 个，两个元素为中心的情况有 n-1 个）
    string longestPalindrome(string s) {
        int len=s.size();
        if(len==0||len==1)
            return s;
        int start=0;//记录回文子串起始位置
        int end=0;//记录回文子串终止位置
        int mlen=0;//记录最大回文子串的长度
        for(int i=0;i<len;i++)
        {
            int len1=expendaroundcenter(s,i,i);//一个元素为中心
            int len2=expendaroundcenter(s,i,i+1);//两个元素为中心
            mlen=max(max(len1,len2),mlen);
            if(mlen>end-start+1)
            {
                start=i-(mlen-1)/2;
                end=i+mlen/2;
            }
        }
        return s.substr(start,mlen);
        //该函数的意思是获取从start开始长度为mlen长度的字符串
    }
private:
    int expendaroundcenter(string s,int left,int right)
    //计算以left和right为中心的回文串长度
    {
        int L=left;
        int R=right;
        while(L>=0 && R<s.length() && s[R]==s[L])
        {
            L--;
            R++;
        }
        return R-L-1;
    }
```

## 6.N字形变换

```c++
string convert(string s, int numRows) {
        /*数学推导
            仔细思考，s中每一个字符在最终result字符串中的位置其实都是能算得出来的
            我们使用字符在s中的索引来表征该字符，下面是N字形变换的结果，记n = numsRows：
            0                2n-2                 4n-4
            1           2n-3 2n-1            4n-5 4n-3  
            .          .     2n             .     .
            .        .       .            .       .
            .      .         .          .         .
            n-2  n           3n-4  3n-2           5n-6
            n-1              3n-3                 5n-5
            可以观察到：
                第一行和最后一行，相邻的两个字符索引之间的差值是2n-2
                其他行，相邻的两个字符索引的和值是(2n-2)*index,index是左边字符在整个行中的索引（index从1开始）
        */
        //特殊处理，因为numRows=1的话，2*numRows-2=0,会导致无限循环，事实上numRows=1直接返回s即可
        if(numRows == 1){
            return s;
        }
        string result;
        int n = s.size();
        for(int i = 0;i < numRows;++i){
            int index = 1,sIndex = i;
            while(sIndex < n){
                if(i == 0 || i == numRows - 1){
                    result.push_back(s[sIndex]);
                    sIndex += 2 * numRows - 2;
                }
                else{
                    result.push_back(s[sIndex]);
                    sIndex = (2*numRows-2)*index - sIndex;
                }
                index++;
            }
        }
        return result;
    }

//数组模拟
class Solution {
public:
   string convert(string s, int numRows) {
		if (numRows == 1) return s;
		vector<string> rows(min(numRows, int(s.size()))); // 防止s的长度小于行数
		int curRow = 0;
		bool goingDown = false;

		for (char c : s) {
			rows[curRow] += c;
			if (curRow == 0 || curRow == numRows - 1) {// 当前行curRow为0或numRows -1时，箭头发生反向转折
				goingDown = !goingDown;
			}
			curRow += goingDown ? 1 : -1;
		}

		string ret;
		for (string row : rows) {// 从上到下遍历行
			ret += row;
		}

		return ret;
	}
```

## 7.整数反转

```c++
 //注意溢出问题 
  int reverse(int x) {
        int rev = 0;
        while (x != 0) {
            if (rev < INT_MIN / 10 || rev > INT_MAX / 10) {		//溢出情况
                return 0;
            }
            int digit = x % 10;
            x /= 10;
            rev = rev * 10 + digit;
        }
        return rev;
    }
```

## 8.字符串转换整数

```c++
//注意数组溢出
int myAtoi(string s) {
        int result = 0;
        int sign = 1;//记录正负号
        int index = 0;

        //1.去掉空格
        while (index < s.size() && ' ' == s[index])index++;
        //2.记录正负号（如果有的话）
        if (index < s.size() && '-' == s[index]) { sign = -1; index++; }
        else if (index < s.size() && '+' == s[index])index++;

        //3.处理数字
        while (index < s.size() && s[index] >= '0' && s[index] <= '9') {
            int num = s[index] - '0';		//单个转换为数字
            if (result > (INT_MAX - num) / 10)return INT_MAX;//超出最大值边界返回最大值,减去num的作用是防止加上num后超出边界。
            if (result < (INT_MIN + num) / 10) return INT_MIN;//超出最小值边界返回最小值，负数需要加上num，作用同上
            result = result * 10 + sign * num;
            index++;
        }
        return result;
    }
```

## 11.盛最多水的容器

![](c++pic\4.png)

```c++
//双指针
int maxArea(vector<int>& height) {
        int l = 0, r = height.size() - 1;
        int ans = 0;
        while (l < r) 
        {
            int area = min(height[l], height[r]) * (r - l);
            ans = max(ans, area);
            if (height[l] <= height[r])  ++l;
            else --r;
        }
        return ans;
    }
};
```

## 12.整数转罗马数字

```c++
![5](C:\CHARLES\Personal\专业\Leetcode\c++pic\5.png)string intToRoman(int num) {
        int values[] = {1000, 900, 500, 400, 100, 90, 50, 40, 10, 9, 5, 4, 1};
        string reps[] = {"M", "CM", "D", "CD", "C", "XC", "L", "XL", "X", "IX", "V", "IV", "I"};

        string res;
        for (int i = 0; i < 13; i ++ )  //这里不使用图里的count了，一遍一遍来就行了
            while(num >= values[i])
            {
                num -= values[i];
                res += reps[i];
            }
        return res;
}
```

## 15.三数之和

![](c++pic\5.png)

```c++
//双指针 + 快速排序
class Solution {
public:
    vector<vector<int>> threeSum(vector<int>& nums) {
        int n=nums.size();
        sort(nums.begin(),nums.end());
        vector<vector<int>> res;
        for(int i=0;i<n;i++)
        {
            if(nums[i] > 0) break;
            if(i>0 && nums[i]==nums[i-1])
            {
                continue;
            }
            int left=i+1;
            int right=n-1;
            int temp=0-nums[i];
            while(left<right)
            {
                if(nums[left]+nums[right]>temp)  right--;
                else if(nums[left]+nums[right]<temp)  left++;
                else
                {
                    vector<int> temp_res={nums[i], nums[left], nums[right]};
                    res.push_back(temp_res);
                    right--;
                    left++;
                    while(nums[left]==nums[left-1]&&left<right) left++;
                    while(nums[right]==nums[right+1]&&left<right) right--;
                }
            }
            
        }
        return res;
    }
};
```

## 16.最接近的三数之和

```c++
class Solution {
public:
    int threeSumClosest(vector<int>& nums, int target) {
        std::sort(nums.begin(),nums.end());
        int len = nums.size();
        int ans = nums[0] + nums[1] + nums[2];
        for(int i = 0; i < len -2; i++)
        {
            //双指针
            int l = i + 1;
            int r = len-1;
            while(l < r)
            {
                int sum = nums[i] + nums[l] + nums[r];
                if(sum == target) return target;
                ans = abs(sum - target) < abs(ans - target) ? sum : ans;
                if(sum < target) l++;
                else r--;
            }
        }
        return ans;
    }
};
```

## 17.电话号码的字母组合

```c++
//回溯法
class Solution {
public:
    string letter[10] ={"","","abc","def","ghi","jkl","mno","pqrs","tuv","wxyz"};   //记录按键的字母
    vector<string> result;
    string s;
    void backtracking(string digits,int startindex){
        if(s.size()==digits.size()){
            result.push_back(s);
            return;
        }
        int digit = digits[startindex] -'0';    //取字符串里的当前数字
        string letters = letter[digit];     //去当前数字手机按键里对应字母集
        for(int i=0;i<letters.size();i++){
            s.push_back(letters[i]);
            backtracking(digits,startindex+1);      //这里不是i，因为字符串每个元素都要遍历
            s.pop_back();
        }
    }
    vector<string> letterCombinations(string digits) {
        if(digits.size()==0){
            return result;
        }
        backtracking(digits,0);
        return result;
    }
};


class Solution {
    string MAPPING[10] = {"", "", "abc", "def", "ghi", "jkl", "mno", "pqrs", "tuv", "wxyz"};
public:
    vector<string> letterCombinations(string digits) {
        int n = digits.length();
        if (n == 0) return {};
        vector<string> ans;
        string path(n, 0);
        function<void(int)> dfs = [&](int i) {
            if (i == n) {
                ans.emplace_back(path);
                return;
            }
            for (char c : MAPPING[digits[i] - '0']) {
                path[i] = c;
                dfs(i + 1);
            }
        };
        dfs(0);
        return ans;
    }
};
```

## 18.四数之和

```c++
class Solution{
	public: 
	vector<vector<int>> fourSum(vector<int>& nums, int target) {
        sort(nums.begin(),nums.end());
        vector<vector<int> > res;
        if(nums.size()<4)
        return res;
        int a,b,c,d,_size=nums.size();
        for(a=0;a<=_size-4;a++){
        	if(a>0&&nums[a]==nums[a-1]) continue;      //确保nums[a] 改变了
        	for(b=a+1;b<=_size-3;b++){
        		if(b>a+1&&nums[b]==nums[b-1])continue;   //确保nums[b] 改变了
        		c=b+1,d=_size-1;
        		while(c<d){
        			if(nums[a]+nums[b]-target<-(nums[c]+nums[d]))//原写法num[a]+num[b]+num[c]+num[d]<target为了防止溢出，见下面的补充修改
        			    c++;
        			else if(nums[a]+nums[b]-target>-(nums[c]+nums[d]))//同上
        			    d--;
        			else{
        				res.push_back({nums[a],nums[b],nums[c],nums[d]});
        				while(c<d&&nums[c+1]==nums[c])      //确保nums[c] 改变了
        				    c++;
        				while(c<d&&nums[d-1]==nums[d])      //确保nums[d] 改变了
        				    d--;
        				c++;
        				d--;
					}
				}
			}
		}
		return res;
    }
};
```



# 困难

## 4.寻找两个正序数组的中位数

```c++
//双指针
class Solution {
public:
    double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
        // 定义 i j 2个指针分别指针2个数组
        // 定义 l r 分别用来保存中位数；奇数个，只会用到 l 变量；偶数，会用到 l r 变量
        int m = nums1.size(), n = nums2.size(), i = 0, j = 0, l = 0, r = 0;
        for (int x = 0; x <= (m + n) / 2; x++) {
            l = r;
            r = (i < m && (j >= n || nums1[i] < nums2[j])) ?			//核心代码
                nums1[i++] : nums2[j++];
        }
        return (m + n) & 1 ? r : (l + r) / 2.0;		//m+n & 1 来判断是否奇偶。奇数用r，偶数用l+r/2
    }
};



//二分查找法
#include <stdio.h>
#include <vector>
using namespace std;

#define max(a,b) (((a) > (b)) ? (a) : (b))
#define min(a,b) (((a) < (b)) ? (a) : (b))

class Solution {
public:
	double findMedianSortedArrays(vector<int>& nums1, vector<int>& nums2) {
		int n = nums1.size();
		int m = nums2.size();

		if (n > m)  //保证数组1一定最短
		{
			return findMedianSortedArrays(nums2, nums1);
		}

		// Ci 为第i个数组的割,比如C1为2时表示第1个数组只有2个元素。LMaxi为第i个数组割后的左元素。RMini为第i个数组割后的右元素。
		int LMax1, LMax2, RMin1, RMin2, c1, c2, lo = 0, hi = 2 * n;  //我们目前是虚拟加了'#'所以数组1是2*n长度

		while (lo <= hi)   //二分
		{
			c1 = (lo + hi) / 2;  //c1是二分的结果
			c2 = m + n - c1;

			LMax1 = (c1 == 0) ? INT_MIN : nums1[(c1 - 1) / 2];
			RMin1 = (c1 == 2 * n) ? INT_MAX : nums1[c1 / 2];
			LMax2 = (c2 == 0) ? INT_MIN : nums2[(c2 - 1) / 2];
			RMin2 = (c2 == 2 * m) ? INT_MAX : nums2[c2 / 2];

			if (LMax1 > RMin2)
				hi = c1 - 1;
			else if (LMax2 > RMin1)
				lo = c1 + 1;
			else
				break;
		}
		return (max(LMax1, LMax2) + min(RMin1, RMin2)) / 2.0;
	}
};


int main(int argc, char *argv[])
{
	vector<int> nums1 = { 2,3, 5 };
	vector<int> nums2 = { 1,4,7, 9 };
	
	Solution solution;
	double ret = solution.findMedianSortedArrays(nums1, nums2);
	return 0;
}
```

