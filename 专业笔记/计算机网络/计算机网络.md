# 计算机网络

## TCP/IP网络模型

不同设备上的进程间通信，就需要网络通信，而设备是多样性的，所以要兼容多种多样的设备，就协商出了一套**通用的网络协议**。

这个网络协议是分层的，每一层都有各自的作用和职责

### 应用层

最上层的，也是我们能直接接触到的就是**应用层**（***Application Layer***），我们电脑或手机使用的**<u>应用软件都是在应用层实现</u>**。那么，当两个不同设备的应用需要通信的时候，应用就把应用数据传给下一层，也就是传输层。

所以，应用层只需要专注于为用户提供应用功能，比如 HTTP、FTP、Telnet、DNS、SMTP等。

应用层是**不用去关心数据是如何传输的**，就类似于我们寄快递的时候，只需要把包裹交给快递员，由他负责运输快递，我们不需要关心快递是如何被运输的。

而且应用层是工作在操作系统中的用户态，传输层及以下则工作在内核态。

### 传输层

应用层的数据包会传给传输层，**传输层**（*Transport Layer*）是**<u>为应用层提供网络支持，也就是说只需要服务好应用即可的</u>**

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E5%BA%94%E7%94%A8%E5%B1%82.png)

在传输层会有两个传输协议，分别是 **<u>TCP 和 UDP</u>**

TCP 的全称叫传输控制协议（*Transmission Control Protocol*），大部分应用使用的正是 TCP 传输层协议，比如 HTTP 应用层协议。TCP 相比 UDP 多了很多特性，比如**<u>流量控制、超时重传、拥塞控制</u>**等，这些都是为了保证数据包能可靠地传输给对方。

UDP 相对来说就很简单，**<u>简单到只负责发送数据包，不保证数据包是否能抵达对方，但它实时性相对更好，传输效率也高</u>**。当然，UDP 也可以实现可靠传输，把 TCP 的特性在应用层上实现就可以，不过要实现一个商用的可靠 UDP 传输协议，也不是一件简单的事情。

应用需要传输的数据可能会非常大，如果直接传输就不好控制，因此当传输层的数据包大小超过 MSS（TCP 最大报文段长度） ，就要将数据包分块，这样即使中途有一个分块丢失或损坏了，只需要重新发送这一个分块，而不用重新发送整个数据包。在 TCP 协议中，我们把每个分块称为一个 **TCP 段**（*TCP Segment*）。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/TCP%E6%AE%B5.png)

当设备作为接收方时，传输层则要负责把数据包传给应用，但是一台设备上可能会有很多应用在接收或者传输数据，因此需要用一个编号将应用区分开来，这个编号就是**端口**

比如 80 端口通常是 Web 服务器用的，22 端口通常是远程登录服务器用的。而对于浏览器（客户端）中的每个标签栏都是一个独立的进程，**操作系统会为这些进程分配临时的端口号**

由于**<u>传输层的报文中会携带端口号，因此接收方可以识别出该报文是发送给哪个应用</u>**

### 网络层

**传输层事实上不负责将数据从一个设备传输到另一个设备，实际的数据传输功能由网络层实现**

实际场景中的网络环节是错综复杂的，中间有各种各样的线路和分叉路口，如果一个设备的数据要传输给另一个设备，就需要在各种各样的路径和节点进行选择，而传输层的设计理念是简单、高效、专注，如果传输层还负责这一块功能就有点违背设计原则了。

也就是说，我们不希望传输层协议处理太多的事情，让其作为应用间数据传输的媒介，帮助实现应用到应用的通信，而**<u>实际的传输功能</u>**就交给下一层，也就是**网络层**（*Internet Layer*）。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E5%B1%82.png)

网络层最常使用的是 **<u>IP 协议（*Internet Protocol*）</u>**

IP 协议会将传输层的报文作为数据部分，再加上 IP 包头组装成 IP 报文，如果 IP 报文大小超过 MTU（以太网中一般为 1500 字节）就会**再次进行分片**，得到一个即将发送到网络的 IP 报文。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

网络层负责将数据从一个设备传输到另一个设备，世界上那么多设备，又该如何找到对方呢？因此，网络层需要有区分设备的编号。

我们一般用 IP 地址给设备进行编号，对于 IPv4 协议， IP 地址共 32 位，分成了四段（比如，192.168.100.1），每段是 8 位。只有一个单纯的 IP 地址虽然做到了区分设备，但是寻址起来就特别麻烦，全世界那么多台设备，难道一个一个去匹配？这显然不科学。

因此，需要将 IP 地址分成两种意义：

- 一个是**网络号**，负责标识该 IP 地址是属于哪个「子网」的；
- 一个是**主机号**，负责标识同一「子网」下的不同主机；

怎么分的呢？这需要配合**子网掩码**才能算出 IP 地址 的网络号和主机号。

举个例子，比如 10.100.122.0/24，后面的`/24`表示就是 `255.255.255.0` 子网掩码，255.255.255.0 二进制是「11111111-11111111-11111111-00000000」，大家数数一共多少个1？不用数了，是 24 个1，为了简化子网掩码的表示，用/24代替255.255.255.0。

知道了子网掩码，该怎么计算出网络地址和主机地址呢？

将 10.100.122.2 和 255.255.255.0 进行**按位与运算**，就可以得到网络号，如下图：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/16.jpg)

将 255.255.255.0 取反后与IP地址进行进行**按位与运算**，就可以得到主机号。

大家可以去搜索下子网掩码计算器，自己改变下「掩码位」的数值，就能体会到子网掩码的作用了。

![子网掩码计算器](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E5%AD%90%E7%BD%91%E6%8E%A9%E7%A0%81%E8%AE%A1%E7%AE%97%E5%99%A8.png)

那么在寻址的过程中，**先匹配到相同的网络号（表示要找到同一个子网），才会去找对应的主机**。

除了寻址能力， IP 协议还有另一个重要的能力就是**路由**

实际场景中，两台设备并不是用一条网线连接起来的，而是通过很多网关、路由器、交换机等众多网络设备连接起来的，那么就会形成很多条网络的路径，因此当数据包到达一个网络节点，就需要通过路由算法决定下一步走哪条路径。

路由器寻址工作中，就是要找到目标地址的子网，找到后进而把数据包转发给对应的网络内。

![IP地址的网络号](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/IP/17.jpg)

所以，**IP 协议的寻址作用是告诉我们去往下一个目的地该朝哪个方向走，路由则是根据「下一个目的地」选择路径。寻址更像在导航，路由更像在操作方向盘**

### 网络接口层

生成了 IP 头部之后，接下来要交给**网络接口层**（***Link Layer***）在 **<u>IP 头部的前面加上 MAC 头部</u>**，并**封装成数据帧（Data frame）**发送到网络上。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/https/%E7%BD%91%E7%BB%9C%E6%8E%A5%E5%8F%A3%E5%B1%82.png)

IP 头部中的接收方 IP 地址表示网络包的目的地，通过这个地址我们就可以判断要将包发到哪里，但在以太网的世界中，这个思路是行不通的。

什么是以太网呢？电脑上的以太网接口，Wi-Fi接口，以太网交换机、路由器上的千兆，万兆以太网口，还有网线，它们都是以太网的组成部分。**<u>以太网就是一种在「局域网」内，把附近的设备连接起来，使它们之间可以进行通讯的技术</u>**。

以太网在判断网络包目的地时和 IP 的方式不同，因此必须采用相匹配的方式才能在以太网中将包发往目的地，而 MAC 头部就是干这个用的，所以，在**<u>以太网进行通讯要用到 MAC 地址</u>**。

**MAC 头部是以太网使用的头部**，它**包含了接收方和发送方的 MAC 地址等信息，我们可以通过 ARP 协议获取对方的 MAC 地址**。

所以说，网络接口层主要为网络层提供「链路级别」传输的服务，负责在以太网、WiFi 这样的底层网络上发送原始数据包，工作在网卡这个层次，使用 MAC 地址来标识网络上的设备。

### 总结

综上所述，TCP/IP 网络通常是由上到下分成 4 层，分别是**应用层，传输层，网络层和网络接口层**。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4@main/%E7%BD%91%E7%BB%9C/tcpip%E5%8F%82%E8%80%83%E6%A8%A1%E5%9E%8B.drawio.png)

再给大家贴一下每一层的封装格式：

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost3@main/%E6%93%8D%E4%BD%9C%E7%B3%BB%E7%BB%9F/%E6%B5%AE%E7%82%B9/%E5%B0%81%E8%A3%85.png)

网络接口层的传输单位是帧（frame），IP 层的传输单位是包（packet），TCP 层的传输单位是段（segment），HTTP 的传输单位则是消息或报文（message）。但这些名词并没有什么本质的区分，可以统称为数据包。

## 键入网址到网页显示流程

接下来以下图较简单的网络拓扑模型作为例子，探究探究其间发生了什么？

![简单的网络模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/2.jpg)

孤单小弟 —— HTTP

> 浏览器做的第一步工作是**<u>解析 URL</u>**

首先浏览器做的第一步工作就是要对 `URL` 进行解析，从而生成发送给 `Web` 服务器的请求信息。

让我们看看一条长长的 URL 里的各个元素的代表什么，见下图：

![URL 解析](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/3.jpg)

所以图中的长长的 URL 实际上是请求服务器里的文件资源。

> 要是上图中的蓝色部分 URL 元素都省略了，那应该是请求哪个文件呢？

当没有路径名时，就代表访问根目录下事先设置的**默认文件**，也就是 `/index.html` 或者 `/default.html` 这些文件，这样就不会发生混乱了。

> 第二步是**<u>生产 HTTP 请求信息</u>**

对 `URL` 进行解析之后，浏览器确定了 Web 服务器和文件名，接下来就是根据这些信息来生成 HTTP 请求消息了。

![HTTP 的消息格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/4.jpg)

------

真实地址查询 —— DNS

通过浏览器解析 URL 并生成 HTTP 消息后，需要委托操作系统将消息发送给 `Web` 服务器。

但在发送之前，还有一项工作需要完成，那就是**查询服务器域名对应的 IP 地址**，因为委托操作系统发送消息时，必须提供通信对象的 IP 地址。

比如我们打电话的时候，必须要知道对方的电话号码，但由于电话号码难以记忆，所以通常我们会将对方电话号 + 姓名保存在通讯录里。

所以，**<u>有一种服务器就专门保存了 `Web` 服务器域名与 `IP` 的对应关系，它就是 `DNS` 服务器</u>**。

> 域名的层级关系

DNS 中的域名都是用**句点**来分隔的，比如 `www.server.com`，这里的句点代表了不同层次之间的**界限**。

在域名中，**越靠右**的位置表示其层级**越高**。

毕竟域名是外国人发明，所以思维和中国人相反，比如说一个城市地点的时候，外国喜欢从小到大的方式顺序说起（如 XX 街道 XX 区 XX 市 XX 省），而中国则喜欢从大到小的顺序（如 XX 省 XX 市 XX 区 XX 街道）。

实际上域名最后还有一个点，比如 `www.server.com.`，这个最后的一个点代表根域名。

也就是，`.` 根域是在最顶层，它的下一层就是 `.com` 顶级域，再下面是 `server.com`。

所以域名的层级关系类似一个树状结构：

- 根 DNS 服务器（.）
- 顶级域 DNS 服务器（.com）
- 权威 DNS 服务器（server.com）

![DNS 树状结构](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/5.jpg)

**<u>根域的 DNS 服务器信息保存在互联网中所有的 DNS 服务器中</u>**。

这样一来，任何 DNS 服务器就都可以找到并访问根域 DNS 服务器了。

因此，客户端只要能够找到任意一台 DNS 服务器，就可以通过它找到根域 DNS 服务器，然后再一路顺藤摸瓜找到位于下层的某台目标 DNS 服务器。

> 域名解析的工作流程

1. 客户端首先会发出一个 DNS 请求，问 www.server.com 的 IP 是啥，并发给本地 DNS 服务器（也就是客户端的 TCP/IP 设置中填写的 DNS 服务器地址）。

2. 本地域名服务器收到客户端的请求后，如果缓存里的表格能找到 www.server.com，则它直接返回 IP 地址

   如果没有，本地 DNS 会去问它的根域名服务器：“老大， 能告诉我 www.server.com 的 IP 地址吗？” 根域名服务器是最高层次的，它不直接用于域名解析，但能指明一条道路。

3. 根 DNS 收到来自本地 DNS 的请求后，发现后置是 .com，说：“www.server.com 这个域名归 .com 区域管理”，我给你 .com 顶级域名服务器地址给你，你去问问它吧。”

4. 本地 DNS 收到顶级域名服务器的地址后，发起请求问“老二， 你能告诉我 www.server.com 的 IP 地址吗？”

5. 顶级域名服务器说：“我给你负责 www.server.com 区域的权威 DNS 服务器的地址，你去问它应该能问到”。

6. 本地 DNS 于是转向问权威 DNS 服务器：“老三，www.server.com对应的IP是啥呀？” server.com 的权威 DNS 服务器，它是域名解析结果的原出处。为啥叫权威呢？就是我的域名我做主。

7. 权威 DNS 服务器查询后将对应的 IP 地址 X.X.X.X 告诉本地 DNS。

8. 本地 DNS 再将 IP 地址返回客户端，客户端和目标建立连接。

至此，我们完成了 DNS 的解析过程。现在总结一下，整个过程我画成了一个图。

![域名解析的工作流程](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/6.jpg)

DNS 域名解析的过程蛮有意思的，整个过程就和我们日常生活中找人问路的过程类似，**只指路不带路**。

> 那是不是每次解析域名都要经过那么多的步骤呢？

当然不是了，还有缓存这个东西的嘛。

浏览器会先看自身有没有对这个域名的缓存，如果有，就直接返回，如果没有，就去问操作系统，操作系统也会去看自己的缓存，如果有，就直接返回，如果没有，再去 hosts 文件看，也没有，才会去问「本地 DNS 服务器」

------

指南好帮手 —— 协议栈

通过 DNS 获取到 IP 后，就可以把 HTTP 的传输工作交给操作系统中的**协议栈**。

协议栈的内部分为几个部分，分别承担不同的工作。上下关系是有一定的规则的，上面的部分会向下面的部分委托工作，下面的部分收到委托的工作并执行。

![img](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/7.jpg)

**应用程序（浏览器）通过调用 Socket 库，来委托协议栈工作。协议栈的上半部分有两块，分别是负责收发数据的 TCP 和 UDP 协议，这两个传输协议会接受应用层的委托执行收发数据的操作**。

协议栈的下面一半是**<u>用 IP 协议控制网络包收发操作</u>**，在互联网上传数据时，数据会被切分成一块块的网络包，而将网络包发送给对方的操作就是由 IP 负责的。

**此外 IP 中还包括 `ICMP` 协议和 `ARP` 协议。**

- **`ICMP` 用于告知网络包传送过程中产生的错误以及各种控制信息。**
- **`ARP` 用于根据 IP 地址查询相应的以太网 MAC 地址。**

IP 下面的网卡驱动程序负责控制网卡硬件，而最下面的网卡则负责完成实际的收发操作，也就是对网线中的信号执行发送和接收操作。

> 数据包看了这份指南表示：“原来我需要那么多大佬的协助啊，那我先去找找 TCP 大佬！”

------

可靠传输 —— TCP

**HTTP 是基于 TCP 协议传输的，所以在这我们先了解下 TCP 协议**。

> TCP 包头格式

我们先看看 TCP 报文头部的格式：

![TCP 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/8.jpg)

首先，**源端口号**和**目标端口**号是不可少的，如果没有这两个端口号，数据就不知道应该发给哪个应用。

接下来有包的**序**号，这个是为了解决包乱序的问题。

还有应该有的是**确认号**，目的是确认发出去对方是否有收到。如果没有收到就应该重新发送，直到送达，这个是为了解决丢包的问题。

接下来还有一些**状态位**。例如 `SYN` 是发起一个连接，`ACK` 是回复，`RST` 是重新连接，`FIN` 是结束连接等。TCP 是面向连接的，因而双方要维护连接的状态，这些带状态位的包的发送，会引起双方的状态变更。

还有一个重要的就是**窗口大小**。TCP 要做**流量控制**，**<u>通信双方各声明一个窗口（缓存大小），标识自己当前能够的处理能力，别发送的太快，撑死我，也别发的太慢，饿死我</u>**。

除了做流量控制以外，TCP还会做**拥塞控制**，对于真正的通路堵车不堵车，它无能为力，唯一能做的就是控制自己，也即控制发送的速度。不能改变世界，就改变自己嘛。

> TCP 传输数据之前，要先三次握手建立连接

**在 HTTP 传输数据之前，首先需要 TCP 建立连接**，TCP 连接的建立，通常称为**三次握手**。

这个所谓的「连接」，只是双方计算机里维护一个状态机，在连接建立的过程中，双方的状态变化时序图就像这样。

![TCP 三次握手](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/TCP%E4%B8%89%E6%AC%A1%E6%8F%A1%E6%89%8B.drawio.png)

- 一开始，客户端和服务端都处于 `CLOSED` 状态。先是服务端主动监听某个端口，处于 `LISTEN` 状态。
- 然后客户端主动发起连接 `SYN`，之后处于 `SYN-SENT` 状态。
- 服务端收到发起的连接，返回 `SYN`，并且 `ACK` 客户端的 `SYN`，之后处于 `SYN-RCVD` 状态。
- 客户端收到服务端发送的 `SYN` 和 `ACK` 之后，发送对 `SYN` 确认的 `ACK`，之后处于 `ESTABLISHED` 状态，因为它一发一收成功了。
- 服务端收到 `ACK` 的 `ACK` 之后，处于 `ESTABLISHED` 状态，因为它也一发一收了。 

![](PIC\0.png)

所以三次握手目的是**保证双方都有发送和接收的能力**。

> 如何查看 TCP 的连接状态？

TCP 的连接状态查看，在 Linux 可以通过 `netstat -napt` 命令查看。

![TCP 连接状态查看](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/10.jpg)

> TCP 分割数据

如果 HTTP 请求消息比较长，超过了 `MSS` 的长度，这时 TCP 就需要把 HTTP 的数据拆解成一块块的数据发送，而不是一次性发送所有数据。

![MTU 与 MSS](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/11.jpg)

- `MTU`：一个网络包的最大长度，以太网中一般为 `1500` 字节。
- `MSS`：除去 IP 和 TCP 头部之后，一个网络包所能容纳的 TCP 数据的最大长度。

数据会被以 `MSS` 的长度为单位进行拆分，拆分出来的每一块数据都会被放进单独的网络包中。也就是在每个被拆分的数据加上 TCP 头信息，然后交给 IP 模块来发送数据。

![数据包分割](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/12.jpg)

> TCP 报文生成

TCP 协议里面会有两个端口：

- 一个是浏览器监听的端口（通常是随机生成的）
- 一个是 Web 服务器监听的端口（HTTP 默认端口号是 `80`， HTTPS 默认端口号是 `443`）

在双方建立了连接后，TCP 报文中的数据部分就是存放 HTTP 头部 + 数据，组装好 TCP 报文之后，就需交给下面的网络层处理。

至此，网络包的报文如下图。

![TCP 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/13.jpg)

------

远程定位 —— IP

TCP 模块在执行连接、收发、断开等各阶段操作时，都需要委托 IP 模块将数据封装成**网络包**发送给通信对象。

> IP 包头格式

我们先看看 IP 报文头部的格式：

![IP 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/14.jpg)

在 IP 协议里面需要有**源地址 IP** 和 **目标地址 IP**：

- 源地址IP，即是客户端输出的 IP 地址；
- 目标地址，即通过 DNS 域名解析得到的 Web 服务器 IP。

因为 HTTP 是经过 TCP 传输的，所以在 IP 包头的**协议号**，要填写为 `06`（十六进制），表示协议为 TCP。

> 假设客户端有多个网卡，就会有多个 IP 地址，那 IP 头部的源地址应该选择哪个 IP 呢？

当存在多个网卡时，在填写源地址 IP 时，就需要判断到底应该填写哪个地址。这个判断相当于在多块网卡中判断应该使用哪个一块网卡来发送包。

这个时候就需要根据**路由表**规则，来判断哪一个网卡作为源地址 IP。

在 Linux 操作系统，我们可以使用 `route -n` 命令查看当前系统的路由表。

![路由表](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/15.jpg)

举个例子，根据上面的路由表，我们假设 Web 服务器的目标地址是 `192.168.10.200`。

![路由规则判断](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/16.jpg)

1. 首先先和第一条目的子网掩码（`Genmask`）进行 **与运算**，得到结果为 `192.168.10.0`，但是第一个条目的 `Destination` 是 `192.168.3.0`，两者不一致所以匹配失败。
2. 再与第二条目的子网掩码进行 **与运算**，得到的结果为 `192.168.10.0`，与第二条目的 `Destination 192.168.10.0` 匹配成功，所以将使用 `eth1` 网卡的 IP 地址作为 IP 包头的源地址。

那么假设 Web 服务器的目标地址是 `10.100.20.100`，那么依然依照上面的路由表规则判断，判断后的结果是和第三条目匹配。

**<u>第三条目比较特殊，它目标地址和子网掩码都是 `0.0.0.0`</u>**，这表示**<u>默认网关</u>**，如果其他所有条目都无法匹配，就会自动匹配这一行。并且后续就把包发给路由器，`Gateway` 即是路由器的 IP 地址。

> IP 报文生成

至此，网络包的报文如下图。

![IP 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/17.jpg)

> 此时，加上了 IP 头部的数据包表示 ：“有 IP 大佬给我指路了，感谢 IP 层给我加上了 IP 包头，让我有了远程定位的能力！不会害怕在浩瀚的互联网迷茫了！可是目的地好远啊，我下一站应该去哪呢？”

------

两点传输 —— MAC

生成了 IP 头部之后，接下来网络包还需要在 IP 头部的前面加上 **MAC 头部**。

> MAC 包头格式

MAC 头部是**<u>以太网使用的头部，它包含了接收方和发送方的 MAC 地址等信息</u>**。

![MAC 包头格式](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/18.jpg)

在 MAC 包头里需要**发送方 MAC 地址**和**接收方目标 MAC 地址**，用于**两点之间的传输**。

一般在 TCP/IP 通信里，MAC 包头的**协议类型**只使用：

- `0800` ： IP 协议
- `0806` ： ARP 协议

> MAC 发送方和接收方如何确认?

**发送方**的 MAC 地址获取就比较简单了，MAC 地址是在网卡生产时写入到 ROM 里的，只要将这个值读取出来写入到 MAC 头部就可以了。

**接收方**的 MAC 地址就有点复杂了，只要告诉以太网对方的 MAC 的地址，以太网就会帮我们把包发送过去，那么很显然这里应该填写对方的 MAC 地址。

所以先得搞清楚应该把包发给谁，这个只要查一下**路由表**就知道了。在路由表中找到相匹配的条目，然后把包发给 `Gateway` 列中的 IP 地址就可以了。

> 既然知道要发给谁，按如何获取对方的 MAC 地址呢？

不知道对方 MAC 地址？不知道就喊呗。

此时就**<u>需要 `ARP` 协议帮我们找到对方路由器的 MAC 地址</u>**。

![ARP 广播](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/19.jpg)

**<u>ARP 协议</u>**会在以太网中以**广播**的形式，**对以太网所有的设备**喊出：“这个 IP 地址是谁的？请把你的 MAC 地址告诉我”。

然后就会有人回答：“这个 IP 地址是我的，我的 MAC 地址是 XXXX”。

如果对方和自己处于同一个子网中，那么通过上面的操作就可以得到对方的 MAC 地址。然后，我们将这个 MAC 地址写入 MAC 头部，MAC 头部就完成了。

> 好像每次都要广播获取，这不是很麻烦吗？

放心，在后续操作系统会把本次查询结果放到一块叫做 **ARP 缓存**的内存空间留着以后用，不过缓存的时间就几分钟。

也就是说，在发包时：

- 先查询 ARP 缓存，如果其中已经保存了对方的 MAC 地址，就不需要发送 ARP 查询，直接使用 ARP 缓存中的地址。
- 而当 ARP 缓存中不存在对方 MAC 地址时，则发送 ARP 广播查询。

> 查看 ARP 缓存内容

在 Linux 系统中，我们可以使用 `arp -a` 命令来查看 ARP 缓存的内容。

![ARP 缓存内容](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/20.jpg)

> MAC 报文生成

至此，网络包的报文如下图。

![MAC 层报文](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/21.jpg)

------

出口 —— 网卡

网络包只是存放在内存中的一串二进制数字信息，没有办法直接发送给对方

因此，我们需要将**数字信息转换为电信号**，才能在网线上传输，也就是说，这才是真正的数据发送过程。

**负责执行这一操作的是网卡**，要控制网卡还需要靠**网卡驱动程序**。

网卡驱动获取网络包之后，会将其**复制**到网卡内的缓存区中，接着会在其**开头加上报头和起始帧分界符，在末尾加上用于检测错误的帧校验序列**。

![数据包](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost4/%E7%BD%91%E7%BB%9C/%E6%95%B0%E6%8D%AE%E5%8C%85.drawio.png)

- 起始帧分界符是一个用来表示包起始位置的标记
- 末尾的 `FCS`（帧校验序列）用来检查包传输过程是否有损坏

最后网卡会将包转为电信号，通过网线发送出去。

> 唉，真是不容易，发一个包，真是历经千辛万苦。致此，一个带有许多头部的数据终于踏上寻找目的地的征途了！

------

送别者 —— 交换机

下面来看一下包是如何通过交换机的。交换机的设计是将网络包**原样**转发到目的地。**<u>交换机工作在 MAC 层</u>**，也称为**二层网络设备**。

> 交换机的包接收操作

首先，电信号到达网线接口，交换机里的模块进行接收，接下来交换机里的模块**<u>将电信号转换为数字信号</u>**。

然**<u>后通过包末尾的 `FCS` 校验</u>**错误，如果没问题则放到缓冲区。这部分操作基本和计算机的网卡相同，但交换机的工作方式和网卡不同。

计算机的网卡本身具有 MAC 地址，并通过核对收到的包的接收方 MAC 地址判断是不是发给自己的，如果不是发给自己的则丢弃；相对地，交换机的端口不核对接收方 MAC 地址，而是直接接收所有的包并存放到缓冲区中

因此，和网卡不同，**交换机的端口不具有 MAC 地址**。

将包存入缓冲区后，接下来需要查询一下这个包的接收方 MAC 地址是否已经在 MAC 地址表中有记录了。

交换机的 **<u>MAC 地址表</u>**主要包含两个信息：

- 一个是设备的 MAC 地址，
- 另一个是**<u>该设备连接在交换机的哪个端口上</u>**。

![交换机的 MAC 地址表](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/23.jpg)

举个例子，如果收到的包的接收方 MAC 地址为 `00-02-B3-1C-9C-F9`，则与图中表中的第 3 行匹配，根据端口列的信息，可知这个地址位于 `3` 号端口上，然后就可以通过交换电路将包发送到相应的端口了。

所以，**交换机根据 MAC 地址表查找 MAC 地址，然后将信号发送到相应的端口**。

> 当 MAC 地址表找不到指定的 MAC 地址会怎么样？

地址表中找不到指定的 MAC 地址。这可能是因为具有该地址的设备还没有向交换机发送过包，或者这个设备一段时间没有工作导致地址被从地址表中删除了。

这种情况下，**<u>交换机无法判断应该把包转发到哪个端口，只能将包转发到除了源端口之外的所有端口上，无论该设备连接在哪个端口上都能收到这个包</u>**

这样做不会产生什么问题，因为以太网的**核心设计**本来就是将包发送到整个网络的，然后**只有相应的接收者才接收包，而其他设备则会忽略这个包**。

有人会说：“这样做会发送多余的包，会不会造成网络拥塞呢？”

其实完全不用过于担心，因为发送了包之后目标设备会作出响应，只要返回了响应包，交换机就可以将它的地址写入 MAC 地址表，下次也就不需要把包发到所有端口了。

局域网中每秒可以传输上千个包，多出一两个包并无大碍。

此外，如果接收方 MAC 地址是一个**广播地址**，那么交换机会将包发送到除源端口之外的所有端口。

以下两个属于广播地址：

- MAC 地址中的 `FF:FF:FF:FF:FF:FF`
- IP 地址中的 `255.255.255.255`

------

出境大门 —— 路由器

> 路由器与交换机的区别

网络包经过交换机之后，现在到达了**路由器**，并在此被转发到下一个路由器或目标设备。

这一步转发的工作原理和交换机类似，也是通过查表判断包转发的目标。

不过在具体的操作过程上，路由器和交换机是有区别的。

- 因为**路由器**是基于 **IP** 设计的，俗称**三层**网络设备，路由器的各个端口都具有 MAC 地址和 IP 地址；
- 而**交换机**是基于**以太网**设计的，俗称**二层**网络设备，交换机的端口不具有 MAC 地址。

> 路由器基本原理

路由器的端口具有 MAC 地址，因此**<u>它就能够成为以太网的发送方和接收方</u>**；同时还具有 IP 地址，从这个意义上来说，它和计算机的网卡是一样的。

当转发包时，首先路由器端口会接收发给自己的以太网包，然后**路由表**查询转发目标，再由相应的端口作为发送方将以太网包发送出去。

> 路由器的包接收操作

首先，电信号到达网线接口部分，路由器中的模块会将电信号转成数字信号，然后通过包末尾的 `FCS` 进行错误校验。

如果没问题则检查 MAC 头部中的**接收方 MAC 地址**，看看是不是发给自己的包，如果是就放到接收缓冲区中，否则就丢弃这个包。

总的来说，路由器的端口都具有 MAC 地址，只接收与自身地址匹配的包，遇到不匹配的包则直接丢弃。

> 查询路由表确定输出端口

完成包接收操作之后，路由器就会**去掉**包开头的 MAC 头部。

**MAC 头部的作用就是将包送达路由器**，其中的接收方 MAC 地址就是路由器端口的 MAC 地址。因此，当包到达路由器之后，MAC 头部的任务就完成了，于是 MAC 头部就会**被丢弃**。

接下来，路由器会根据 MAC 头部后方的 `IP` 头部中的内容进行包的转发操作。

转发操作分为几个阶段，首先是查询**路由表**判断转发目标。

![路由器转发](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/24.jpg)

具体的工作流程根据上图，举个例子。

假设地址为 `10.10.1.101` 的计算机要向地址为 `192.168.1.100` 的服务器发送一个包，这个包先到达图中的路由器。

判断转发目标的第一步，就是根据包的接收方 IP 地址查询路由表中的目标地址栏，以找到相匹配的记录。

路由匹配和前面讲的一样，每个条目的子网掩码和 `192.168.1.100` IP 做 **& 与运算**后，得到的结果与对应条目的目标地址进行匹配，如果匹配就会作为候选转发目标，如果不匹配就继续与下个条目进行路由匹配。

如第二条目的子网掩码 `255.255.255.0` 与 `192.168.1.100` IP 做 **& 与运算**后，得到结果是 `192.168.1.0` ，这与第二条目的目标地址 `192.168.1.0` 匹配，该第二条目记录就会被作为转发目标。

实在找不到匹配路由时，就会选择**默认路由**，路由表中子网掩码为 `0.0.0.0` 的记录表示「默认路由」。

> 路由器的发送操作

接下来就会进入包的**发送操作**。

首先，我们需要根据**路由表的网关列**判断对方的地址。

- 如果网关是一个 IP 地址，则这个IP 地址就是我们要转发到的目标地址，**还未抵达终点**，还需继续需要路由器转发。
- 如果网关为空，则 IP 头部中的接收方 IP 地址就是要转发到的目标地址，也是就终于找到 IP 包头里的目标地址了，说明**已抵达终点**。

知道对方的 IP 地址之后，接下来需要通过 `ARP` 协议根据 IP 地址查询 MAC 地址，并将查询的结果作为接收方 MAC 地址。

路由器也有 ARP 缓存，因此首先会在 ARP 缓存中查询，如果找不到则发送 ARP 查询请求。

接下来是发送方 MAC 地址字段，这里填写输出端口的 MAC 地址。还有一个以太类型字段，填写 `0800` （十六进制）表示 IP 协议。

网络包完成后，接下来会将其转换成电信号并通过端口发送出去。这一步的工作过程和计算机也是相同的。

发送出去的网络包会通过**交换机**到达下一个路由器。由于接收方 MAC 地址就是下一个路由器的地址，所以交换机会根据这一地址将包传输到下一个路由器。

接下来，下一个路由器会将包转发给再下一个路由器，经过层层转发之后，网络包就到达了最终的目的地。

不知你发现了没有，在网络包传输的过程中，**源 IP 和目标 IP 始终是不会变的，一直变化的是 MAC 地址**，因为需要 MAC 地址在以太网内进行**两个设备**之间的包传输。

------

互相扒皮 —— 服务器 与 客户端

数据包抵达了服务器，服务器肯定高兴呀，正所谓有朋自远方来，不亦乐乎？

服务器高兴的不得了，于是开始扒数据包的皮！就好像你收到快递，能不兴奋吗？

![网络分层模型](https://cdn.xiaolincoding.com/gh/xiaolincoder/ImageHost/%E8%AE%A1%E7%AE%97%E6%9C%BA%E7%BD%91%E7%BB%9C/%E9%94%AE%E5%85%A5%E7%BD%91%E5%9D%80%E8%BF%87%E7%A8%8B/25.jpg)

数据包抵达服务器后，服务器会先扒开数据包的 MAC 头部，**<u>查看是否和服务器自己的 MAC 地址符合，符合就将包收起来</u>**。

接着继续扒开数据包的 IP 头，发现 IP 地址符合，根据 IP 头中协议项，知道自己上层是 TCP 协议。

于是，扒开 TCP 的头，里面有序列号，**需要看一看这个序列包是不是我想要的，如果是就放入缓存中然后返回一个 ACK，如果不是就丢弃。TCP头部里面还有端口号， HTTP 的服务器正在监听这个端口号**。

于是，服务器自然就知道是 HTTP 进程想要这个包，于是就将包发给 HTTP 进程。

服务器的 HTTP 进程看到，知**<u>道了这个请求是要访问一个页面，于是就把这个网页封装在 HTTP 响应报文里</u>**。

HTTP 响应报文也需要穿上 TCP、IP、MAC 头部，不过这次是源地址是服务器 IP 地址，目的地址是客户端 IP 地址。

穿好头部衣服后，从网卡出去，交由交换机转发到出城的路由器，路由器就把响应数据包发到了下一个路由器，就这样跳啊跳。

最后跳到了客户端的城门把守的路由器，路由器扒开 IP 头部发现是要找城内的人，于是又把包发给了城内的交换机，再由交换机转发到客户端。

客户端收到了服务器的响应数据包后，同样也非常的高兴，客户能拆快递了！

于是，客户端开始扒皮，把收到的数据包的皮扒剩 HTTP 响应报文后，交给浏览器去渲染页面，一份特别的数据包快递，就这样显示出来了！

最后，客户端要离开了，向服务器发起了 TCP 四次挥手，至此双方的连接就断开了。

![](PIC\1.png)

> **为什么“握手”是三次，“挥手”却要四次？**
>
> TCP建立连接时之所以只需要"三次握手"，是**<u>因为在第二次"握手"过程中，服务器端发送给客户端的TCP报文是以SYN与ACK作为标志位的。SYN是请求连接标志，表示服务器端同意建立连接；ACK是确认报文，表示告诉客户端，服务器端收到了它的请求报文。</u>**
>
> 即SYN建立连接报文与ACK确认接收报文是在同一次"握手"当中传输的，所以"三次握手"不多也不少，正好让双方明确彼此信息互通。
>
> TCP释放连接时之所以需要“四次挥手”,是因为**<u>FIN释放连接报文与ACK确认接收报文是分别由第二次和第三次"握手"传输的</u>**。为何建立连接时一起传输，释放连接时却要分开传输？
>
> 建立连接时，被动方服务器端结束CLOSED阶段进入“握手”阶段并不需要任何准备，可以直接返回SYN和ACK报文，开始建立连接。**<u>释放连接时，被动方服务器，突然收到主动方客户端释放连接的请求时并不能立即释放连接，因为还有必要的数据需要处理，所以服务器先返回ACK确认收到报文，经过CLOSE-WAIT阶段准备好释放连接之后，才能返回FIN释放连接报文</u>**。
>
> 所以是“三次握手”，“四次挥手”。

## 课程主要内容介绍 

**网络层**是在**链路层多个P2P连接（点对点）**的基础上实现的**E2E（端到端）**

网络层现在分为**传统方式（IP,路由）**和**SDN**

**传统工作方式**:

- **IP**：**使用算好的路由表**，把到来的IP分组匹配路由表，从自己不同的**网卡**将分组**转发**出去
- **路由器**：计算路由表

**SDN（软件定义网络）**:

- 数据平面是**交换机**，**上载算好的流表**，根据**流表匹配**后可以**转发，屏蔽，改字段**得到的**分组**
- 控制平面是**操作系统**，运行各种网络应用，计算**流表**，然后通过标准协议发送给交换机

## **第一章**

计算机网络五层结构：

1. **应用层**
2. **传输层**
3. **网络层（路由器）**
4. **数据链路层（交换机）**
5. **物理层**

#### 节点

- **主机=端系统及其上运行的应用程序**
- **路由器，交换机等网络交换设备**

#### 边

代表**通信链路**

- **接入网链路：主机连接到互联网的链路**
- **主干链路：路由器间的链路**

**协议**控制发送，接收消息：如TCP,IP,HTTP,FTP,PPP等等

![](PIC\2.png)

分布式应用是网络存在的理由

**通信基础设施为apps提供编程接口（通信服务）**

1. 将发送和接受数据的apps与互联网连接起来

2. 为app应用提供服务选择，类似邮政服务：

   - **无连接不可靠服务**

   - **面向连接的可靠服务**

![](PIC\3.png)

网络的构成由三个子系统构成：边缘系统，接入系统，核心系统

**边缘（PC，手机等）通过接入系统接入核心，核心连接起边缘，使得任意两个端系统可以通信**

> 核心的实际工作原理还是依靠路由器，交换机和链路相互构成的分布式系统

![](PIC\4.png)

#### 客户端/服务器模式

**可扩展性比较差**，在**负载超过阈值时传输速度会出现断崖式下降**

#### P2P模式

每个节点**既是客户端，也是服务器**，很多**文件分发系统采用这种模式**，比如**迅雷可以向别的客户端请求文件服务，自己也可以提供文件，而且不同片段可以从不同的客户端分别下载，这种同时下载可以获得带宽的聚集，速度更快。**

TCP有**流量控制**的特性：**协调发送方发送速度和接收方接受速度**

#### 网络核心

电路交换

![](PIC\5.png)

![](PIC\6.png)

![7](PIC\7.png)

##### **频分**

**FDM**，交换节点之间带宽比较宽，有效频率覆盖范围也广，通过频分多路复用的方式，**每两个主机通信之前找到链路上空闲的一段频率进行通信**

##### **时分**

**TDM**,按照时间来分，再每个T中分为32片或24片，采用划分时隙的方式，第一个用户用第一片，第二个用户用第二片，以此类推，比如10个人用这条链路，则每个用户分得总带宽/10的带块

> **统计多路复用**是一种特殊的时分复用

##### 波分

**WDM**,**光纤中使用**,类似频分和时分，链路中**可用的波段划分为小波段**，每个用户使用一个小波段

例：

![](PIC\8.png)

##### 分组交换

![](PIC\9.png)

网络核心的关键功能

**路由**：决定分组采用的源到目标的路径

**转发**：将分组**从路由器的输入链路转移到输出链路**

![](PIC\10.png)

**分组交换和电路交换相比允许更多用户使用网络**

##### 总结

![12](PIC\12.png)

#### 接入网络

指标是**带宽，共享还是独享**

##### 调制解调器

**modulator和demodulator**

![](PIC\13.png)

因为电话线用来传音频的，所以通常**带宽非常窄，而且打电话和上网不能同时进行。**

##### 线缆网络

有线电视公司就采用这个方式

![](PIC\14.png)

![](PIC\15.png)

##### 无线接入网络

无线网络有两种方式：**LAN和无线广域**

![](PIC\16.png)

##### 物理媒体

![](C:\Charles\Personal\专业\计算机网络\PIC\17.png)

![18](C:\Charles\Personal\专业\计算机网络\PIC\18.png)

光纤中传播的是光信号，**很难受到电磁波的干扰**

光线技术是华人发明的，通过光传输提高了非常多的倍数，大大提高了有效带宽

本拉登被抓到的传闻：本拉登的助手使用移动通信打了电话，被定位到后，海豹突击队出手

**无线链路**

![](PIC\19.png)

#### Internet结构和ISP

![](PIC\20.png)

端系统都会通过**接入ISPs**连接入互联网，例如：住宅，公司和大学的ISPs。接入ISPs都是互联的

因为**不能采取全连接**的方式连接ISPs（规模是O（n^2）），所以在全球部署**global ISP**来完成全局范围的覆盖

![](PIC\21.png)

ISP并不是独占，多个拥有全局ISP的互相竞争合作，如AT&T，电信，联通，移动

![](PIC\22.png)

**通过多个ISP合作可以扩展用户和业务范围**

**IXP：互联网交换点**，完成ISP之间流量交换

> ​		**内容提供商（ICP）们，如谷歌，微软等会构建自己的网络，将它们的服务、内容更加靠近端用户，向用户提供更好的服务，减少自己的运营支出**，这些公司会在全球各地地方布置自己的**DC（数据中心机房）**，甚至Google在海里光缆。通常部署位置都很**靠近ISP的节点**，或者**温度很低的地方或者很安全的地方**（如**深山里，深海里，甚至北极也有，节约降温的成本**）然后用**自己的专线连接起来**，主要原因：
>
> - **ISP收费太高**
> - **无法保证提供高质量服务**

![](PIC\23.png)

![24](PIC\24.png)

#### 分组延时、丢失、吞吐量

 ![](PIC\25.png)

四种分组延时：

- **节点处理延时**：检查bit级差错，检查分组首部并决定导向何处
- **排队延时**：在输出链路上等待传输的时间，依赖于路由器的拥塞程度
- **传输延时**：R=链路带宽，L=分组长度，将分组发送到链路上的时间=L/R
- **传播延时**：d=物理链路的长度，s=在媒体上的传播速度，传播延时=d/s

> **时延**：指数据从网络的一端传送到另一端所需的时间
>
> **发送时延（传输时延）**：是主机或路由器发送数据帧所需要的时间，也就是从发送数据帧的第一个比特算起，到该帧的最后一个比特发送完毕所需的时间，发送时延 = 数据帧长度(b) / 信道带宽(b/s)
>
> **传播时延**：是电磁波在信道中传播一定的距离需要花费的时间，传播时延 = 信道长度(m) / 电磁波在信道上的传播速率(m/s)
>
> **<u>传播时延dp = 信道长度(m) / 电磁波在信道上的传播速率(m/s) = M / V</u>**
>
> 发送时延（传输时延）发生在机器的内部的发送器中，而传播时延则发生在机器外部的传输信道媒体上。
>
> **处理时延**：主机或路由器在收到分组时要花费一定的时间进行处理，例如分析分组的首部、从分组中提取数据部分、进行差错或查找适当的路由等等
>
> **排队时延**：分组在经过网络传输时，要经过许多的路由器。但分组在进入路由器后要现在输入队列中排队等待处理。在路由器确定了转发接口后，还要在输出队列中排队等待转发
>
> 数据在网络中经历的总时延就是以上四种时延之和：总时延 = 发送时延 + 传播时延 + 处理时延 + 排队时延
>
> **时延带宽积**：时延带宽积 = 传播时延 * 带宽

LAN：信道容量小

WAN：信道容量大

![](PIC\26.png)

**流量强度**

![](PIC\27.png)

ICMP

互联网控制报文协议

![](PIC\28.png)

吞吐量：在源端和目标端之间传输的速率

- 瞬间吞吐量：在一个时间点的速率
- 平均吞吐量：在一个长时间内的平均值

#### 协议层次及服务模型 

计算机网络是一个异常复杂的大系统

通过**模块化或分层**可以实现复杂的功能，计算机网络就是采用分层的形式

![](PIC\29.png)

![](PIC\30.png)

**本层协议的实现需要下层提供的服务，实现本层协议的目的是为了向上层提供更好的服务。**

**DU**：数据单元

**上层的SDU + 本层的头部（控制信息） = 本层PDU**（协议数据单元）

**五层模型**

![](PIC\31.png)

**ISO参考模型**

更抽象一点

![](PIC\32.png)

##### 各层数据单元

![](PIC\33.png)

![34](PIC\34.png)

## **第二章 应用层**

C/S模式用户量达到一定程度后性能会呈**断崖式下降**

p2p系统节点数量在增加，同时提供服务的节点数量也在增加，就能够实现维持性能

所以p2p系统如迅雷**可以很容易扩展到几百万级用户量，但是缺点是难以管理**

**Web应用默认端口：80**

**FTP：21**

**Telnet：23**

传输层引入了端口号来**标识进程**，网络层用IP地址**标识主机**

**层间接口**需要携带的信息：**<u>谁发的，发给谁，传输的数据</u>**

#### Socket

**本地操作系统管理的TCP端口号，IP地址以及对方的TCP端口号和IP地址的<u>本地标识，表示一种会话关系</u>**，用来**减少层间（应用层 和 传输层）传输的数据量，方便操作系统管理**，是一个**四元组**，再加上一个PID标识进程可以存进操作系统中的socket表里

![](PIC\36.png)

**SocketAPI**：传输层向网络层提供的接口

![](PIC\35.png)

![](PIC\37.png)

UDPsocket：是一个两元组，**IP和端口号，<u>由于没有握手，发送报文时必须要指定对方的IP和udp port</u>**

![](PIC\38.png)

#### Web和HTTP

Web页由许多**对象**组成，其中基本的HTML文件**包含若干对象的<u>URL引用</u>**

![](PIC\40.png)

URL格式

![](PIC\39.png)

**HTTP：超文本传输协议**

使用的是**TCP**，守候Socket是80端口，等待别的客户端请求的连接

![](PIC\41.png)

HTTP1.0：**非持久HTTP**

连接请求，连接确认，请求对象，对象回来，**<u>关闭连接</u>**

![](PIC\42.png)

![](PIC\43.png)

HTTP1.1：**持久HTTP**

连接请求，连接确认，请求对象，对象回来，**<u>不会关闭连接，可以直接开启下一次请求</u>**

默认模式是**流水方式，<u>不用等待上一个请求的响应</u>**

![](PIC\44.png)

#### HTTP请求报文

HTTP报文：**请求、响应**

![](PIC\45.png)

> **HEAD请求多用于搜索引擎，因为头部包括网页的描述信息，可以用于建立索引**

![](PIC\46.png)

![47](PIC\47.png)

**GET命令可以没有实体部分（直接放在url里上载请求信息），但POST命令需要实体部分，因为<u>提交的一些表单的信息包含于实体上</u>**

**<u>PUT，DELETE</u>命令一般是网站管理员使用，来删除或者管理URL规定的文件**

#### HTTP响应报文

![](PIC\48.png)

![](PIC\49.png)

HTTP本质是一个**无状态协议**，服务器不维护客户端状态

#### Cookie

​		**相当于一个<u>用户ID</u>。用户首次访问时，服务器给客户端一个cookie，并在<u>服务器和客户端（浏览器）保存下这个cookie，之后客户端访问每次把cookie加入首部行</u>，在服务器维护的数据库中保存用户的信息**

**四个部分**：

1. 用户第一次访问，服务器生成一个cookie，HTTP响应报文中一个cookie首部行
2. HTTP请求报文中一个cookie首部行
3. 在用户端系统中保留有一个cookie文件，并由浏览器管理
4. Web站点后端数据库中保存一个cookie

![](PIC\50.png)

**作用：可以不用重复登陆，购物车状态保留，广告推荐算法等**

缺点：隐私可能会被暴露，服务器端保留有个人喜好和网站访问行为等相关信息

#### Web缓存

缓存既是**客户端的也是服务器端的，通常由<u>ISP（互联网服务提供商）</u>安装**。在本地命中后，就可以减轻服务器负载，同时减轻网络负载

> 按照主营的业务划分，中国ISP主要有以下几类 
>
> 1. 搜索引擎ISP 如**百度，Google**等
>
> 2. 即时通信ISP 即时通信ISP主要提供基于互联网和基于移动互联网的即时通信业务。由于即时通信的ISP自己掌握用户资源，因此在即时通信的业务价值链中，即时通信ISP能起到主导作用，这在同运营商合作的商业模式中非常少见。运营商也在发力即时通信，如移动的飞信、电信的易信。 
>
> 3. 移动互联网业务ISP 移动互联网业务ICP主要提供**移动互联网服务**，包括：WAP上网服务、移动即时通信服务、信息下载服务等
>
> 4. 门户ISP提供新闻信息、文化信息等信息服务 门户ISP以向公众提供各种信息为主业，具有稳定的用户群。门户ISP的收入来源比较广，包括在线广告、移动业务、网络游戏及其他业务。比如：新浪、搜狐、网易和雅虎等门户网站（包括行业门户）
>
> 5. 在邮件营销领域，ISP主要指电子邮箱服务商 RFC 6650给电子邮箱服务商的定义是：为终端用户提供邮件发送、接收、存储服务的公司或组织。这个定义涵盖了电子邮件托管服务、以及自主管理邮件服务器的公司、大学、机构和个人。 常见的电子邮件服务商，国内有网易、腾讯、新浪、搜狐等主流ISP。国外常见的有Gmail、Yahoo、Hotmail、AOL等
>
>    ​		这些ISP通常通过执行**邮件传输协议（SMTP）、交互式邮件存取协议（IMAP）、邮局协议(POP)** 及其他专有协议进行信息的传输和获取。

原理：**同一区域的用户的访问具有趋同性，80%用户经常访问20%的网页**

##### 流量强度

**当流量强度I = La/R （R  = 链路带宽（链路宽度），L= 分组长度 ，a=分组到达队列的平均速率（分组数量）） ，约等于1时，用户等待响应时间无限长**

> 若La/R越接近于1：排队延时越大，因为排队的车队中每个车队都有间距，当第一次车队通过关卡，后面车队进来需要移动一定间距才能进入关卡，这边会造成延时，导致车队通过关卡的同时，第二批车队不能直接通过关卡，而后续车队也在进来，导致道路继续拥挤，因此越接近于1，延时越高，等于1时，延时趋近于无穷。

解决方法：

- **增加链路带宽**（也就是分母），但价格太过昂贵
- **安装本地缓存**，只有ISP就亏钱了（NICE！）

![](PIC\52.png)

**条件GET方法**

如果某个时间后服务器端的对象数据修改了才需要传给我，如果没有修改就不用传输了，**<u>用来解决缓存对象和服务器端数据一致性问题</u>**

![](PIC\53.png)

#### FTP

**一种文件传输协议 RFC959** 

> Request For Comments，缩写为RFC，是由互联网工程任务组（IETF）发布的一系列备忘录。文件收集了有关互联网相关信息，以及UNIX和互联网社群的**软件文件，以编号排定**

服务器守候在**21端口**，等待客户端来请求连接（**控制命令连接**）。**然后服务器<u>主动</u>跟客户端20端口建立连接（数据连接）**

**特点：控制命令和数据传输分别在两个TCP上进行的**

![](PIC\54.png)

![](PIC\55.png)

![](PIC\56.png)

#### SMTP

**邮件服务器**之间的协议

> 邮件服务器：邮箱管理和维护。发送给用户的代理邮件，**对方用户<u>从代理邮件服务器通过POP3</u>拉取下来查看邮件**
>
> **POP3：邮局访问协议，用户身份确认后从代理服务器下载，用户名和密码用户确认时都是明文，所以安全性较差**
>
> **IMAP：Internet消息访问协议（IMAP）是用于从本地客户端访问远程服务器上的电子邮件的标准协议，比POP拥有更多特性，可以在服务器上处理存储的报文，<u>远程目录维护</u>**
>
> 使用IMAP，用户可以随时随地访问电子邮件，**因为所有电子邮件都保留在服务器上**，直到客户端明确地将其服务器中删除；每当用户检查收件箱时，该用户的电子邮件客户端都会与服务器联系，以便将用户与邮件联系起来。
>
> **用户使用IMAP阅读电子邮件时，实际上并未将其下载或存储在用户的计算机上；而是正在从服务器上读取邮件**。因此，可以从多个不同的设备检查自己的电子邮件，而不会遗漏任何东西。

原理：使用TCP在客户端和服务器之间传送报文，服务器端守候在**25端口**

![](PIC\57.png)

例：

发送时放到邮件服务器的**报文队列**中，可以**隔一段时间统一发送，节省资源**

![](PIC\58.png)

**与HTTP比较**：

**<u>HTTP一个响应报文至多一个对象，SMTP一个响应报文可以包含多个对象</u>**（图片，文字等等）

![](PIC\59.png)

#### DNS

域名系统，**完成域名到ip地址的解析**

IP地址用于在网络上**标识主机、路由器**

为了**防止重名**，采用的**<u>层次化命名</u>（www，edu，com等等）**

Internet根被划为几百个**顶级域，分为通用和国家的**

![](PIC\60.png)

将DNS空间划分为许多互不相交的区域，每个域是树的一部分

名字服务器：每个区域里都有个名字服务器，维护着它所管辖的区域权威信息

![](PIC\61.png)

##### 工作流程

![](PIC\62.png)

**递归查询**：**<u>从后往前一个一个往前（cn,edu...），从树顶搜索到叶子节点</u>**

![](PIC\63.png)

迭代查询：当前联络的服务器没有缓存，但会给出可能知道的下层服务器名字

![](PIC\64.png)

DNS基本是**很可靠和安全的**，原因是：

- 根目录服务器**配置了流量过滤器，防火墙等防止DDoS攻击**
- 大部分Local DNS服务器都**缓存了顶层服务器的IP地址，无需向根服务器查询**
- 发送伪造的应答给DNS服务器，希望他缓存这个错误的结果，**技术上很难实现分布式截获和伪造**

![](PIC\65.png)

#### P2P应用

**文件分发（BT，BitTorrent），流媒体，VoIP(Skype)**

C/S模式的文件分发：

![](PIC\66.png)

取决于F文件大小，N客户端数量，us上传速度，D，d下载速度

下载时间**<u>随着N线性增加</u>**

P2P模式：

![](PIC\67.png)

**<u>随着N增加，整体下载量也增加，同时peer节点的增多也增强了服务能力，同时具备可扩展性</u>**

**对比图**：

![](PIC\68.png)

用户下载时，别的用户也可以从他这里下载，既是Web服务器，也是一个瞬时服务器

难点：

> **如何定位所需资源?**
>
> **如何动态管理节点的加入与退出?**

##### 非结构化P2P

集中式目录 

![](PIC\69.png)

**特点：存在一个目录中心服务器，用户上线时会告知其有什么资源，中心服务器维护有效在线客户端和资源，可扩展性好**

> **问题：单点故障，性能瓶颈，版权问题**

##### 完全分布式

例：**Gnutella**

**特点：<u>没有中心服务器</u>，开放文件共享协议（<u>开源</u>），许多Gnutella客户端实现了Gnutella协议（类似HTTP有许多不同浏览器一样）**

**可扩展性：限制范围（例如TTL，只传播5次或7次等等，或者中转节点记住，第二次收到相同查询不再传播）的<u>泛洪查询</u>**

##### 混合式

例：**KaZaA，BitTorrent**

分成各个小组，还有组长。组长和组长间是分布式，组长和组员内是集中式的

![](PIC\70.png)

每个文件有个**描述信息 + Hash散列值（文件唯一标识）**

###### BitTorrent

**<u>Torrent</u>**：**洪流，节点组成的组，之间可以交换文件块。每个节点有个<u>Bitmap</u>，256kB,自己拥有的资源相应位置标记为1，没有的标记为0，<u>*定期所有peer节点在洪流中交换Bitmap和资源 *</u>**

**种子**：**拥有全部文件的节点，<u>Bitmap全部为1</u>，可以选择离开（利己主义），也可以留在洪流中（利他主义）**

![](PIC\71.png)

**扰动：洪流中的节点会有进有出，动态平衡**

> **BT下载**是P2P下载模式其中的一种，这里的P2P（Peer to Peer）并非金融上的P2P，而是指数据传输不再通过服务器，网络用户可以直接进行数据传输的一种对等网络。**P2P模式中无中心服务器**，网络中的每个节点即可以作为客户端进行下载，也可以作为节点服务器提供给他人下载。这种下载方式的特点是**<u>文件下载的人数越多，下载的速度就越快</u>**。
>
> BT下载过程解析：
>
> 下载者会先得到一个**.torrent的种子文件**。**"种子文件"**本质上是一个文本文件：由**<u>Tracker信息和文件信息</u>**两部分组成。 其中Tracker（译：追踪者）信息就是在整个BT下载过程中非常重要的Tracker服务器的信息。**包含Tracker服务器的地址和服务器相关的设置，<u>用以提供其他用户的ip地址</u>**。而文件信息对应的是我们需要下载的文件的相关信息，**包含文件块的大小，块索引，Hash验证码等。** 
>
> 下载者使用BT客户端软件进行下载，BT客户端：
>
> 1. **先对torrent文件进行解析，得到Tracker地址，根据地址连接到Tracker服务器**
> 2. Tracker服务器会返回信息告知下载者，**该文件其他下载者（此时其他下载者作为服务器）的IP地址**。
> 3. 下载者根据ip地址**<u>连接"其他下载者"</u>**，**下载者之间相互交换对方没有的文件块**
>
> ​       在整个BT下载过程中，**<u>每个文件块的下载都会有验证和对比，确保数据下载的准确性</u>**。 没有中心化的WEB服务器介入，**全程点对点，用户对用户，只有一个Tracker服务器提供其他用户的ip地址**。传统下载方式中服务器上行带宽的压力，在BT下载中不存在。参与下载的用户自行解决。

##### DHT（结构化P2P）

BT下载有其优势，也有缺点。文件传输不经过中心化的服务器，无法进行管控，**文件的安全性没有保障，盗版和非法的文件横行**。BT下载遭到打压。而对于BT下载来说只需要将Tracker服务器关掉就可以阻断下载。 **<u>虽然BT下载是去中心化下载，但Tracker服务器还是一个中心化的环节</u>**。有没有一种方法，**<u>可以延续P2P下载的优势，还能不需要Tracker服务器这类中心化的组件</u>**，答案是：有，DHT网络技术。

**DHT技术**：**分布式哈希表**

![](PIC\72.png)

**磁力链接**

![](PIC\73.png)

磁力链接工作流程：

​		当我们点击某个磁力链接地址，然后在某个下载软件sw中打开。sw会**<u>实例化一个DHT节点并加入</u>**，将磁力链接中的40个字符提取并处理得到20字节的infohash，向距离该infohash最近的几个节点发送get_peers请求，得到节点回复的peers列表，sw软件会实例化一个BT客户端并向这些peers请求下载种子文件。得到种子文件，其中如果包含tracker，就像BT下载那样下载数据。如果其中不包含Tracker，那其中会有真正资源的node列表，则会向这些node节点发送下载请求，下载资源。

​		**<u>磁力下载方式，并不是取代BT种子文件的下载方式。只是在没有Tracker服务器的情况下，通过DHT网络找到种子文件进行下载，DHT的作用是将所有节点变成Tracker服务器。</u>**

**ed2k**

​		eDonkey2000 network，一种**<u>分布式文件共享网络</u>**，文件基于P2P原理存放在用户的电脑上，客户端程序连接到这个网络来共享文件。共享文件夹中的的文件会生成ed2k链接，其他人通过该链接就可以拿到共享文件夹中的文件。 ed2k常见的客户端：eDonkey2000，eMule，VeryCD等。 edek的客户端说白了，其实是一个共享软件。而BT和磁力下载对应的是下载软件。

#### CDN

**CDN（Content Distribution Networks）：内容分发网络**

**视频流服务约占了网络流量的80%**，视频的带宽非常大。

> **视频**：**图像所构成的序列**，可以分为一个个帧。图像又是一个个像素点的序列
>
> **<u>如果没有压缩，音频，视频不能在网络上传播，因为浪费的带宽太大了。通常会转换为小码率的视频进行传播。</u>**
>
>  **CBR（constant bit rate）：固定速率编码**
>
>  **VBR（variable bit rate）：视频编码速率随着时间而变化**

**流化服务：<u>利用缓冲区，一边下载一边播放</u>**

**DASH**：**动态自适应流化服务**，在HTTP协议上传输

![](PIC\74.png)

**服务器端：**

1. **将视频文件分为多个块（一般每块8s~10s）**
2. **每个块都负责不同码率或编码标准**
3. **一个视频上载到流媒体服务器时，是有很多版本的不同的块**
4. **清单文件（manifest file）告诉整个视频的分块以及每一块的URL和描述信息**

**客户端：**

1. **下载并查看清单文件**
2. **<u>将后续播放需要的块</u>加入缓冲区（动态决定不同码率的块），一边播放视频，保证尽可能实现流化播放**

![](PIC\75.png)

##### 思路

**在全球网络中<u>部署了很多*缓存节点*，预先存储服务内容</u>，就近为用户提供加速服务（减少网络中的跳数）**，如**Akamai**，中国**阿里云，腾讯云**，**蓝迅公司**

> CDN，内容分发网络**，**是指一种透过互联网互相连接的电脑网络系统，利用最靠近每位用户的服务器，更快、更可靠地将音乐、图片、视频、应用程序及其他文件发送给用户，来提供高性能、可扩展性及低成本的网络内容传递给用户。其基本思路是尽可能避开互联网上有可能影响数据传输速度和稳定性的瓶颈和环节，使内容传输的更快、更稳定。

![](PIC\76.png)

**ICP**（ Internet Content Provider，**网络内容服务商，如CCTV，百度等**）都会购买CDN的服务，**<u>将自己的内容部署在缓存节点</u>**，以此来**加速服务用户的质量**

#### TCP套接字编程

**Socket**：**分布式应用进程之间的门，传输层协议提供的端到端服务接口。应用进程借助Socket发送，接受报文，最后关闭**

**<u>2种传输层服务的socket类型：TCP（可靠，字节流），UDP（不可靠，数据报）</u>**

**TCP套接字**：应用进程**端到端**的**<u>*会话关系*</u>**，可靠地传输字节流

![](PIC\77.png)

**服务器端：**

1. 创建一个欢迎socket（一个整数），与本地ip + 80端口捆绑
2. 阻塞式等待接收用户连接，返回一个connect socket

**客户端：**

1. 创建客户端本地socket，绑定到本地端口
2. **指定对方服务器端IP和端口**，与服务器请求建立TCP连接，并受到应答

#### UDP套接字编程 

**区别**：**不用建立连接，所以不需要welcome socket，只用一个socket来传输数据**

 客户端和服务器端之间**<u>*没有连接，没有握手*</u>**

发送端在每一个报文中**<u>明确地指定目标IP和端口</u>**，**<u>服务器从收到的分组提取出发送端IP和端口</u>**

从进程角度：UDP提供了**<u> </u>**传送服务

流程：

**服务器端**

1. 服务器建立一个socket，返回一个整数
2. 绑定端口
3. 从socket阻塞式接受信息

**客户端**

1. 建立socket
2. 绑定本地端口
3. 发送消息，指明socket和数据

#### 总结

基于TCP的协议：Http，Https，FTP，SMTP（简单邮件传输协议），Telnet
基于UDP的协议：DNS,DHCP,TFTP，SNTP（简单网络管理协议）

例如QQ采用TCP和UDP，qq通话和视频通话，发视频都采用UDP

## **第三章 传输层**

**主要的两个传输 协议：TCP 和 UDP**

**发送方：<u>将应用层报文分为报文段</u>，然后传递给网络层**

**接收方：<u>将报文段重组成报文</u>并传递给应用层**

![](PIC\78.png)

![](PIC\79.png)

### 多路复用和解复用

![](PIC\80.png)

TCP复用解复用

**<u>本质就是发送方给包加TCP头部，加IP头部，接收方解开包头部信息来获取ip和端口端口，匹配自己的socket表格发送给对应的进程</u>**

![](PIC\81.png)

![](PIC\83.png)

UDP复用解复用

**区别：Socket表<u>只存储本地的IP和端口</u>，udp数据帧传到tcp的时候<u>需要告诉对方的IP和端口，再加上传输的数据</u>**

![](PIC\82.png) 

### UDP

**UDP** :User Datagram Protocol,**用户数据报协议**

负责提供**<u>进程与进程之间的服务</u>**（下层的IP提供主机到主机的服务）

主要用于UDP，SNMP，DNS等等

为了在UDP实现可靠传输需要：

- **在应用层增加可靠性**
- **应用特定的差错恢复**

#### 数据报协议

**校验和**：判断数据报传输过程中是否出错，如果出错就会被扔掉.**<u>16位数值等于进位回滚后的反码，如果为ffff就是正确传输</u>**

![](PIC\84.png)

![](PIC\85.png)

**残存错误**：网络下载的大文件有时打不开的原因，**<u>数据传输部分和校验和同时出错</u>**

![](PIC\86.png)

rdt ：可靠数据传输协议

信道的不可靠特点决定了可靠数据传输协议的复杂性

![](PIC\87.png)

package带序号传输，保证数据一定送到，如果是重复传输丢弃即可

**rdt2.1：ACK + NAK**

![](PIC\88.png)

**rdt2.2：无NAK协议，只使用ACK（ack会<u>*编号*</u>）**

![](PIC\89.png)

核心：**使用对前一个数据单位的ACK代替本数据单位的NAK，<u>确认信息减半</u>，协议处理起来更简单**

**rdt3.0：具有比特差错和分组丢失的信道**

![](PIC\90.png)

**缺点：在信道容量比较大的情况下，<u>效率比较低，利用率很低</u>，主要原因是一次只发一个分组**

![](PIC\91.png)

利用**<u>流水线方式</u>**可以**提高链路利用率**

![](PIC\92.png)

 **流水线协议**：允许发送方在未得到对方确认的情况下一次发送多个分组

两种通用的流水线协议：**回退N步（GBN）和选择重传（SR）**

### 滑动窗口协议

![](PIC\93.png)

**发送窗口**

![](PIC\94.png)

**发送窗口大小达到发送缓冲区长度的时候必须等待收到下一个确认才能移动滑动窗口**

![](PIC\95.png)

**接受窗口**

接受窗口 = 1的时候，叫做**GBN协议**，只能**顺序接受分组**

#### GBN

发送方只维持**最老的已发送未确认的分组的计时器**

![](PIC\348.png)

![](PIC\349.png)

#### SR

- **接受窗口 > 1，等于发送窗口大小**
- 每个分组都是**单独的**确认接受，来哪个分组给哪个分组的确认
- 低序号分组没收到时，**高序号分组也可以缓存下来（buffered）**，低序号分组的超时计时器后会重传
- **<u>只有最下沿的分组收到后才能移动滑动窗口</u>**

![](PIC\350.png)

![](PIC\351.png)

![](PIC\352.png)

**接受窗口 > 1的时候**，叫做**SR协议**，可以**乱序接受分组**，对每个分组会**单独**发回确认。 当低序号分组没收到的时候，高序号分组可以缓存，但不能移动。直到最下沿的分组收到后，才会移动接受窗口

![](PIC\96.png)

例：接受窗口为4的模拟

![](PIC\97.png)

### TCP

![](PIC\98.png)

**MSS**：TCP报文段中的**应用层数据部分**，最大报文段长度（MSS）是TCP协议的一个选项，用于在TCP连接建立时，收发双方协商通信时每一个报文段所能承载的最大数据长度（不包括文段头）

**MTU**：一般指最大传输单元。 最大传输单元（Maximum Transmission Unit，*MTU*）用来通知对方所能接受数据服务单元的最大尺寸，

**<u>MSS + TCP头部 + IP头部 = MTU</u>**

![](PIC\99.png)

![](PIC\100.png)

#### RTT

**往返延时：RTT**

TCP的超时定时器设置要比RTT长，但也不能太短（会导致过早超时，造成不必要的重传）

一般设置为**均值 + 4*标准差，超过就当分组丢失**

![](PIC\101.png)

![](PIC\102.png)

**快速重传**：凭借发送方收到的**冗余ACK（因为中间丢了一组包）**，**<u>在超时定时器超时前就重传了</u>**

![](PIC\103.png)

#### 流量控制

**核心：接收方控制发送方，不让发送送的太快以致于<u>接收方的缓冲区溢出，没有足够字节来存储</u>**

![](PIC\104.png)

方法：捎带技术，**把自己<u>空闲缓冲区的大小</u>告诉对方**  

如果是两次握手，可能会产生很多半连接（统一客户端可能因为超时重复请求连接，服务器端都同意，还会接受后续多余数据，浪费服务器很多资源）

![](PIC\105.png)

#### 	3次握手

变化的初始序号 +  双方确认对方的序号

![](PIC\106.png)

初始序号：为了区分同一端口的新老数据

> **老端口结束后，新端口建立后，老端口的数据传达到了，服务器端可能错误接受**

三次握手建立连接的过程中，会在SYN报文中使用**MSS（Maximum Segment Size）选项功能**，协商交互双方能够接收的最大段长MSS值。MMS一般**<u>*根据网卡的MTU值*</u>**计算而得。

MSS是传输层TCP协议范畴内的概念，顾名思义，其标识TCP能够承载的最大的应用数据段长度，因此，MSS=MTU-20字节TCP报头-20字节IP报头，那么在以太网环境下，**MSS值一般就是1500-20-20=1460字节**。

最后，交互双方会以**<u>*双方通告的MSS值中取最小值作为发送报文的最大段长*</u>**。下例中此TCP连接后续的交互过程中，服务器端向客户端发送的报文中的TCP的最大段长度将都是1440字节

![](PIC\157.png)

#### 拥塞控制

链路的带宽 R 当吞吐量达到R/2时，吞吐量不再增加，因为链路带宽就这么多，**流量强度接近1，延迟特别大**

![](PIC\107.png)

拥塞的解决方案：

![](PIC\108.png)

**拥塞控制方法**

- 端到端的拥塞控制：没有来自网络的反馈，**<u>根据延迟和丢失事件来推导网络中是否发生了拥塞</u>**
- 网络辅助的拥塞控制：端系统**<u>根据网络的反馈</u>**，采取**自适应的发送速率**

![](PIC\109.png)

**TCP拥塞控制**

采用**端到端**的拥塞控制，用网络辅助的话效果会好，**<u>但是网络流量代价太大</u>**

如何检测拥塞：

![](PIC\110.png)

控制发送端发送速率：

收到三个冗余的ACK后，将控制窗口减小为一半

![](PIC\111.png)

拥塞控制和流量控制的联合

**CongWin**：拥塞窗口值

**RecvWin**：接受缓冲区中的空闲尺寸，保存在字段里由对方告知我们

![](PIC\112.png)

##### 慢启动

![](PIC\113.png)

**慢启动阶段（AIMD）**：初始速率很慢，但是**<u>指数级增加</u>**窗口长度，**只要不超时或者3个重复ack，CongWin加倍**（**<u>指数增加</u>**）

**上一步中超时的速率的一半作为<u>警戒值</u>。下一次CongWin增加到警戒值时候，每收到一个ACK，ConeWin加1**（**<u>CA（拥塞避免阶段），线性增加</u>**）

![114](PIC\114.png)

**总结**

![](PIC\115.png)

![](PIC\116.png)

## **第四章   网络层**

关键功能：**<u>*转发和路由*</u>**

**转发**：将分组**从路由器输入接口<u>转发</u>到合适的输出接口**

**路由**：由**<u>路由算法</u>**来**决定分组从发送主机到目标接受主机的路径**

在**主机之间**发送段，发送端将段封装到数据报中，接收端将段交给上层传输层

路由器检查每一个经过它的IP数据报头部， **解封装， 匹配下一跳路由器，再封装**

![](PIC\117.png)

网络层通常分为**数据平面**和**控制平面**

![](PIC\118.png)

 **传统方式**：路由实体分布式计算了路由表，交给IP协议实体，**根据到来的分组匹配，之后转发**

控制平面**计算路由表**，数据平面根**据路由表转发**

![](PIC\120.png)

**SDN方式**：逻辑集中的控制平面

SDN（**软件定义网络**）：服务器运行**一个远程控制器**和每个路由器的本地控制代理交互，控制代理上报状态，服务器计算后流表后传回

使得整个网络**不再固化，具有弹性**，通过修改集中式服务器就可以修改网络行为

![](PIC\121.png)

### 网络层服务模型

根据不同模式向上层提供不同的服务

![](PIC\122.png)

### 路由器

#### 输入端口

会加入缓存区，因为Head of Line**（HOL）** blocking，排在队头的数据报阻止了队列中其他数据报向前移动

![](PIC\124.png)

![](PIC\123.png)

#### 交换结构

目的：**将分组从输入缓冲区传输到合适的输出端口**

**<u>交换速度一定是输入线路速度的N倍（N个输入端口）才不会成为瓶颈，不然会造成阻塞</u>**

![](PIC\125.png)

##### memory

第一代路由器。两端都是以太网网卡，  通过**<u>内存</u>**交换，分组拷贝到**系统内存，CPU提取目标IP，查找路由表，找到对应输出端口，拷贝到输出端口**

一次只能转发一个分组，经过系统总线BUS**两次**

![](PIC\126.png)

##### 总线传输

数据报**<u>共享总线</u>**，从输入端口转发到输出端口，**<u>只需要经过BUS总线一次</u>**，**交换速率能够达到几十Gbps，明显高于基于memory的**。**交换速度受限于总线带宽**

![](PIC\127.png)

##### crossbar

基于互联网络（非真正的互联网络）的交换,可以达到**<u>60Gbps</u>**的交换速率

![](PIC\128.png)

#### 输出端口

**调度机制**：目的是选择**下一个要通过链路传输的分组**

1. **<u>FIFO</u>**，先到先转发出去
2. <u>**优先权**</u>：发送最高优先权的分组
3. <u>**RR**</u>（Round Robin）：**循环扫描不同类型的队列**，发送完一类分组再发送下一个类的分组
4. WFQ（Weight Fair Queuing）：每个队列得到的服务时间和**权重成正比例**
5. **<u>丢弃策略</u>**：分组到时队列满了，需要选择丢弃分组

- tail drop：丢弃刚到达的分组
- **priority：按照优先级丢弃分组**
- random：随机丢弃

![](PIC\129.png)

![130](PIC\130.png)

### IP协议

***主要功能：<u>数据平面的转发</u>***

网络划分**公网（连Internet的）**与**内网**。

#### 公有IP地址

一般称公网中的**IP地址**为公有地址。公有地址由Inter NIC（因特网信息中心）负责，这些**IP地址**分配给**注册**并向Inter NIC提出申请的组织机构。公有地址是全球唯一的，公网中不可能存在两个相同的**IP地址**。

**范围**：除了私有地址以外的地址，都属于公有地址

#### 私有IP地址

一般称内网（即局域网）中的**IP地址**为私有地址。私有地址是**非注册地址**，用于组织机构内部使用。私有地址的范围如下：

**<u>网络号的第一组数字来区分A,B,C类</u>**

- A类IP地址中：10.0.0.0--10.255.255.255
- B类IP地址中：172.16.0.0--172.31.255.255
- C类IP地址中：192.168.0.0--192.168.255.255

> **IP地址有三种基本类型**，由网络号的第一组数字来表示：
>
> **A类地址的第一组数字为1～126。注意，数字0和 127不作为A类地址，数字127保留给内部回送函数，而数字0则表示该地址是本地宿主机，不能传送。**
>
> **B类地址的第一组数字为128～191。**
>
> **C类地址的第一组数字为192～223。**

私有地址与公有地址不同，并不是由**Internet**分配的，是不允许出现在**Internet**中的，我们在公网中是看不到**私有IP地址**的，并且***公有地址也不会使用上述的三类地址***。所以，私有地址是不能直接与**Internet**连接的。

而如果想用私有地址与Internet连接来访问公网，那该怎么做？这就需要将**私有IP地址**转换成**公网IP地址**，与外部连接。所以，我们平时使用的路由器中会装有一个叫做 **NAT（网络地址转换）** 的软件，我们的路由器中会至少会有一个有效的**公网IP**，**NAT**会将我们的**私有地址**转成路由器中的**公网IP**与外部Internet连接。而同样的，因为使用的是路由器中的**公共的公网IP**来连接Internet，所以这个内网中的PC在Internet中显示的都是路由器的**公共IP**，这样做不仅提供了一定程度的安全，也可以有效的减缓可用的IP地址空间的枯竭问题。（像我们学校或者公司的内网一般都是这么做的）

另外还有一点，在同一个局域网内，IP地址是唯一的；但是在不同的局域网内，IP地址是可以重复出现的。

> **举个小例子:** 在**局域网A**中，有个主机的**IP地址**是`192.168.10.128`，那么绝不可能在**局域网A**中还有其他主机的**IP地址**为`192.168.10.128`。但是在**局域网B**中却可以有主机的**IP地址**也是`192.168.10.128`。
>  如果**局域网A**中的`192.168.10.128`**主机**与**局域网B**中的`192.168.10.128`**主机**通信，不会冲突吗？不会，因为上述说过，它们最终都是使用路由器中的`公网IP`来连接外网的，而`公网IP`是全球唯一的。

#### localhost、127.0.0.1、0.0.0.0、255.255.255.255、本机IP区别

**localhost**

**localhost**其实是`域名`，一般windows系统默认将**localhost**指向`127.0.0.1`，但是**localhost**并不等于`127.0.0.1`，**localhost**指向的**IP地址**是可以配置的

> 首先 localhost 是一个域名，在过去它指向 127.0.0.1 这个IP地址。在**操作系统支持 ipv6 后，它同时还指向ipv6 的地址 [::1]** 
>
> 在 Windows 中，这个域名是预定义的，从 **hosts 文件**中可以看出：
>
> \# localhost name resolution is handled within DNS itself.
>
> \# 127.0.0.1 localhost
>
> \# ::1 localhost
>
> 而在 Linux 中，其定义位于 **/etc/hosts** 中：
>
> 127.0.0.1 localhost
>
> 注意这个值是可修改的，比如把它改成
>
> 192.068.206.1 localhost
>
> 然后再去 ping localhost，提示就变成了
>
> PING localhost (192.168.206.1) 56(84) bytes of data.

**127.0.0.1**

***主机上发送给`127`开头的IP地址的数据包会被发送的主机自己接收***

首先我们要先知道一个概念，凡是以`127`开头的**IP地址**，都是**回环地址（Loop back address）**，其所在的回环接口一般被理解为虚拟网卡，**<u>*并不是真正的路由器接口*</u>**。

所谓的回环地址，通俗的讲，就是我们在主机上发送给`127`开头的**IP地址**的数据包会被发送的主机自己接收，根本传不出去，外部设备也无法通过回环地址访问到本机。

> **小说明**：正常的`数据包`会从`IP层`进入`链路层`，然后发送到`网络`上；而给`回环地址`发送`数据包`，`数据包`会直接被发送主机的`IP层`获取，后面就没有`链路层`他们啥事了。

而`127.0.0.1`作为`{127}`集合中的一员，当然也是个回环地址。只不过`127.0.0.1`经常被默认配置为**localhost**的**IP地址**。
 一般会通过`ping 127.0.0.1`来测试某台机器上的网络设备是否工作正常。

**0.0.0.0 和 255.255.255.255**

***用于动态配置获取ip***

> **静态IP(static ip)**是相对于动态IP而言的，是指网络中IP地址只能由管理员进行配置的互联网地址。**静态IP通常用于大型企业网或骨干网等对安全性要求高的场合**。例如：在路由器上进行手工配置时使用的都是静态IP
>
> 为了解决多路复用问题，"DHCP服务"提供了两种解决方案：
>
> 一是采用固定端口的方式来实现多路复用方案；
>
> 二是利用路由器的路由功能来解决这一问题——这就是我们常说的"默认路由",也就是我们所指的"静态路由"

![](PIC\364.png)

**<u>0.0.0.0是一个非常特殊的[IP地址](https://baike.baidu.com/item/IP地址/150859?fromModule=lemma_inlink)，这个IP相当于[java](https://baike.baidu.com/item/java/85979?fromModule=lemma_inlink)中的this，代表当前设备的IP。</u>**

***表示本机中所有的IPV4地址，本机中所有IP的端口***

首先，`0.0.0.0`是不能被`ping`通的。在服务器中，`0.0.0.0`并不是一个真实的的**IP地址**，它表示本机中所有的**IPV4地址**。监听`0.0.0.0`的端口，就是监听本机中所有**IP**的端口。

**<u>255.255.255.255是一个广播地址</u>**

> **目的 ip 填 255.255.255.255 代表这是一个广播报文**，会发给局域网内的所有主机。其他主机收到广播报文之后，会进行判断这个广播报文是否是发给自己的，如果是发给自己的，则进行处理，否则就把这个广播报文丢弃。
>
> 最后 DHCP 服务器终于收到了我的广播，这个时候问题来了，DHCP服务器是如何知道我是来请求一个 ip 的呢？
>
> 为了解决这个问题，我们需要在报文里做一个标记，告诉 DHCP服务器我是来请求报文的，于是，啥也没有的我，在报文的源地址里填了 0.0.0.0。当**DHCP服务器看到报文的源地址是 0.0.0.0时， 就知道我还没有被分配过 ip，急需一个ip来去冲浪了**

**本机IP**

**本机IP**通常仅指在同一个局域网内，能同时被外部设备访问和本机访问的那些**IP地址**（可能不止一个）。像`127.0.0.1`这种一般是不被当作**本机IP**的。**本机IP**是与具体的网络接口绑定的，比如以太网卡、无线网卡或者PPP/PPPoE拨号网络的虚拟网卡，想要正常工作都要绑定一个地址，否则其他设备就不知道如何访问它。

**小例子剧场（帮助理解本机IP、127.0.0.1和0.0.0.0）**

现在有两台pc在同一个局域网内，分别为pc1与pc2，pc1上有一个网卡，IP地址为`192.168.10.128`

- pc1中server监听`127.0.0.1`，则pc1中的client可以连上`127.0.0.1`，`192.168.10.128`连不上；而pc2中client都连不上。
- pc1中server监听`192.168.10.128`，则pc1中的client可以连上`192.168.10.128`，`127.0.0.1`连不上；而pc2中client能连上`192.168.10.128`。
- pc1中server监听`0.0.0.0`，则pc1中的client可以连上`127.0.0.1`和`192.168.10.128`，pc2中的client能连上`192.168.10.128`。

**体系结构中的位置**

![](PIC\131.png)

![](PIC\132.png)

####  IP分片和重组

网络链路有**MTU（最大传输单元）**，根据MTU来分组

一个大的数据报被**分割成若干个数据报**，都具有：

- **相同的ID**（标记是来自一个数据报）
- **不同的偏移量**（到达时间可能不一样，确保有序）
- 最后一个分片标记为0

**<u>如果任何一片小数据报没传到，接收端会丢弃其余的所有分组，等待这个大数据报重传</u>**

![](PIC\133.png)

例：

![](PIC\134.png)

#### IP地址

**32位**标识，对于主机或路由器接口的标识

![](PIC\135.png)

#### 子网

具备两个条件：

- 这些IP前缀一样（前三个字节），叫做**子网号**
- 子网内部分组**<u>无需路由器介入，分组转发一跳可达</u>**

##### IP地址分类

**A**：地址**<u>最高位为0</u>**，第一个字节的其余7个比特为**网络号**，后面3个字节的**24比特是主机号**，**126个网络**，**2^24-2个主机地址**（2^7-2，**全0和全1规定不用**）

**B**：最高地址两位是**10**，**前两个字节代表网络号，后两个字节为主机号**。**2^14-2个网络，2^16-2个主机**

**C**：A和B类地址早就被分完了，前面3位是**110**，前面三个字节是网络号，后面一个字节是主机号。**200万+的网络**，**254个（2^8-2）**主机

D：ABC都叫**单播地址**，D叫**主播地址（属于D类组的成员都可以收到）**，第一个字节为**1110**

![](PIC\136.png)

**特殊的网络IP地址**

本网络：子网全0

本主机：主机部分全0

广播地址：主机部分全1

![](PIC\137.png)

**127开头**的地址叫**环回地址**，也叫**测试地址**，**到达IP层的时候反转回去TCP层**

**169.254.0.0 - 169.254.0.16 链接本地地址 Link-Local Address**

**127.0.0.0 - 127.0.0.8 换回地址**

**0.0.0.0 - 0.0.0.8 用于在当前网络中通信**

![](PIC\138.png)

**内网IP地址**

也叫**专用地址**：**<u>地址空间的一部分供专用地址使用</u>，不会被当作公用地址分配，只在局域网络中有意义，用以区分不同设备**，路由器也不会对目标地址是专用地址的分组转发。**<u>*多用于网络测试，试运行业务等等*</u>**

**CIDR**

无类域间路由

> **IP的路由表在查路由的时候，是<u>以子网网络号为单位进行匹配</u>的**

![](PIC\139.png)

##### 子网掩码

**作用：<u>把网络号提取出来，将主机号都置零</u>，用以匹配对应网络号的表项并转发分组**

![](PIC\140.png)

#### DHCP

两种获得IP地址的方式：

- 网络管理员给你配置
- **DHCP（Dynamic Host Configuration Protocol）**：设备运行DHCP协议，从DHCP服务器**自动获得上网所需要配置**的四个信息：**<u>IP，子网掩码，Local Name Server，默认网关</u>**

![](PIC\141.png)

DHCP目的：**允许主机在加入网络后，<u>动态地从DHCP服务器那里获得IP地址</u>**

![](PIC\142.png)

![](PIC\143.png)

实例：**<u>*流程就是：客户端先广播，DHCP服务器后单播*</u>**

![](PIC\144.png)

![](PIC\145.png)

**路由聚集**

可以理解为**多个路由的<u>*公共前缀合并*</u>**，将他们**路由通告聚集后一起**通知ISP

目的：<u>**减少路由表项的数量，减少路由信息通告代价，减少路由存储和计算的代价**</u>

路由表表项匹配的时候可能有多个路由匹配，选择**<u>最长前缀匹配（更精确的匹配）</u>**

![](PIC\146.png)

**实例**：

![](PIC\147.png)

#### NAT

NAT：Network Address Translation

目的：**<u>*实现外网地址和内网地址的转换*</u>**。出去的时候转换为外网地址，进入内网的时候转换为内网地址

![](PIC\148.png)

![](PIC\149.png)

**实例**

![](PIC\150.png)

问题：

- 路由器应该只对第三层信息做处理，这里还对端口号做了处理
- 违反了end-to-end的原则，复杂性应该放到网络边缘中
- ip地址不够

NAT问题的本质是**ip地址不够**，可以**<u>通过IPV6来解决</u>**

**NAT穿越**：外网客户端想要主动连接内网的主机

方案：

- 静态配置NAT：转发进来的对服务器特定端口连接，直接写死
- **UPnP：允许查询NAT已经存在的端口映射，然后动态增删端口映射**
- 中继：借助中继服务器在两个连接之间作为桥接

#### IPV6

**初始动机：IPV4的32位的地址空间已经用完**

Ipv4和ipv6都是**地址协议**，和网速没有关系。网速是由宽带速度等其他因素决定的。然而，**ipv6网络比ipv4网络具有<u>更大的带宽</u>**。带宽就像公路的宽度，网速就像汽车的速度。这将减**少网络拥塞，并间接提高网络速度**。

> 当初**IPV4只是国防部支持的分组交换实验网项目**，没想到互联网发展这么迅速
>
> **IPV5**是一个实验室协议，**只不过IPv5在成为标准之前就被放弃了**
>
> IPv5互联网协议是由 **Apple、NeXT 和 Sun Microsystems**开发的一种**<u>流式传输视频和语音数据的方法</u>**，是具有实验性的探索。
>
> IPv5从**未过渡到公共使用，很大程度上是由于<u>其 32 位的限制</u>**。**IPv5沿用了IPv4的32位寻址，这是主要的问题。**

IPV6的改变：

- **IP地址的数量**：IPv4协议具有**32位**(4字节)地址长度;IPv6协议具有**128位**(16字节)地址长度，**<u>即有2^128-1个地址</u>**。
- 安全性：IPv6的安全性更高，用户**<u>可以在网络层认证与加密数据并对 IP 报文进行校验</u>**

> IPv6集成了**Internet协议安全标准（IPSec**）。IPv6的网络安全不像IPv4是可选项，**IPv6里的网络安全项是强制性的**

- 传输速度：去掉checksum，IPv6的**路由表更小，聚合能力更强，提升了网络数据转发的效率**
- **数据包大小**：对于IPv4，最小数据包大小为**576字节**。对于IPv6，最小数据包大小为**1208字节**
- **header区域字段数**：IPv4具有12个标头字段，而IPv6支持8个标头字段。

![](PIC\151.png)

地址的表示方法：IPv4地址是以小数表示的二进制数。 IPv6地址是以十六进制表示的二进制数。即使IPv6的地址是IPv4地址的4倍。但报头只有它的2倍大。

![](PIC\152.png)

##### IPV4到IPV6的过渡

因为如今用户和主机数量过于庞大，不能用革命性升级（约定一个时间统一宕机然后升级），只能采用**<u>平滑升级</u>**的方法

**双栈**：IPV6和IPV4的边缘

**<u>隧道</u>（Tunneling）**：IPV4分组中完整携带IPV6分组，之后解封

**原理：刚开始IPV6借助IPV4 <u>隧道</u> 互相通信，等到IPV6比IPV4还多的时候，IPV4利用IPV6互相通信，最后慢慢取代**

![](PIC\153.png)

### SDN简介

目的：**<u>将路由器的控制平面与数据平面分离</u>**

上中下三个部分：**控制应用，SDN控制器，数据平面交换机**

设立逻辑上集中的控制平面的原因：

- **网络管理更加容易：<u>避免路由器的错误配置</u>**
- **基于流表的转发：允许<u>可编程的路由器</u>**
- **控制平面的开放实现**

![](PIC\177.png)

![](PIC\154.png)

![](PIC\155.png)

![](PIC\156.png)

**控制器和分组交换机：**

![](PIC\178.png)

![](PIC\179.png)

实例：

## **第五章 网络层控制平面**

![](PIC\158.png)

### 路由选择算法

- **link state**
- **distance vector**

目的：从**<u>源主机到目标主机选出最佳路径</u>**传输数据

常用指标：**<u>站数，延迟，费用，队列长度</u>**或者加权平均

![](PIC\159.png)

核心：发现最小代价

![](PIC\160.png)

**汇集树（sink tree）**

- **此节点到其他所有结点的最优路径形成的树**
- 路由选择算法就是**<u>找出所有节点的汇集树</u>**

路由选择算法的原则：

- **正确性**
- **简单性**
- **健壮性**

![](PIC\162.png)

路由算法分类：**全局**或者**分布式**

#### link state

**链路状态算法**：本质就是**<u>Dijkstra算法</u>**

![](PIC\163.png)

流程：

1. **发现相邻节点**，计算自己节点到周围邻居的**<u>链路代价信息</u>**
2. **组装一个<u>LS分组</u>，描述它到相邻节点的代价情况**
3. 之后将分组**<u>泛洪（flooding）</u>**，快速扩散传播全网所有路由器![](PIC\164.png)
4. 每个路由器都**获得整个网络的拓扑结构和边代价**
5. 运用**Dijkstra算法**计算最短路径

![](PIC\165.png)

![](PIC\166.png)

![](PIC\167.png)

#### Distance vector 

是一种基于**Bellman-ford方程（动态规划）**的算法

> 贝尔曼-福特算法(Bellman-Ford)是由理查德·贝尔曼和菜斯特·福特创立的，**<u>求解单源最短路径问题的─种算法</u>**。它的原理是对图进行**<u>*V-1次松弛操作，得到所有可能的最短路径*</u>**。
>
> 其**<u>优于Dijkstra算法</u>**的方面是**边的权值可以为负数、实现简单**
>
> 缺点是**时间复杂度过高**

**距离矢量算法**：和链路状态路由选择一样是**动态路由选择算法之一**

核心：**<u>*定期和自己的邻居交换距离矢量的数据，更新自己的数据*</u>**

![](PIC\168.png)

实例：

![](PIC\169.png)



![](PIC\170.png)

缺点：**坏消息传播非常慢**，要TTL超时或者无穷次迭代才能**判断出一个节点是<u>不可达</u>的**

解决方法：**水平分裂算法（split horizon）和<u>毒性逆转</u>算法：动态路由协议中为避免转发回路所采用的一种方法。它禁止把在一个接口上接收到的关于一个网络的路由信息再在同一接口上通告，解决路由自环，以避免回路的发生。**

![](PIC\171.png)

毒性逆转和水平分割 作为 **RIP 预防环路的两个手段**  

- **水平分割：你发送给我的路由 我就不能再发送给你了**  
- **毒性逆转：接收到路由后 立即向发送这条路由的路由器发送 一条跳数为16（因为RIP协议中的TTL最大是15，图论上的意义就是代价被续成了无穷大∞）的毒性路由，预防环路  相比之下 毒性逆转更主动一些，但是也有缺点，就是增大了路由表的规模大小**

> **RIP(Routing Information Protocol)**协议是内部网关协议IGP中最先广泛使用的协议之一。RIP是一种分布式的**基于距离矢量的路由选择**协议。**<u>通告报文通过UDP报文周期性传送</u>**

如果自治区内只有25个子网及以下，就可以用RIP算法来计算，**如果网络太大就不能用距离矢量算法**

![](PIC\172.png)

###  BGP

ISP之间的路由选择 

**层次路由**

可扩展性强 

![](PIC\173.png)

**BGP：边界网关协议**

作用：将各个AS联系在一起

- eBGP：外部BGP，收集自治区内部的子网可达信息，通过eBGP告诉其他网关
- iBGP：内部BGP，告诉自治区内部所有子网外部收到的可达信息

![](PIC\174.png)

**网关路由器会同时运行eBGP和iBGP**

![](PIC\175.png)

![](PIC\176.png)

## **第六章 链路层和局域网**

**相邻两个节点之间传输以<u>帧为单位</u>的数据**，数据报会在不同的链路上以不同的链路协议传送

![](PIC\180.png)

**点对点连接**：用于**广域网**或拨号接入

**多点连接**：用于**局域网**，因为距离比较近，所以**<u>接入一个交换机</u>**的集合

> **广域网不用多点连接的原因：物理限制上长距离布局很麻烦，而且长途范围内铺设的电路带宽一定非常大，延迟也比较大，很容易造成碰撞，造成的损失非常大**

![181](PIC\181.png)

### 链路层服务

- 流量控制
- 错误检测,差错纠正
- 半双工和全双工

![182](PIC\182.png)

### 网卡

**网卡**：**NI**C，也叫网络接口卡，或者**网络适配器**，**<u>*实现链路层的功能*</u>**，接到主机的系统总线上，写死自己的mac地址

![](PIC\183.png)

**工作流程：发送方封装完分组，系统通过<u>*网卡驱动*</u>把分组交给网卡，网卡收到分组后<u>*封装成帧*</u>，借助网卡物理层的功能，将帧变为物理信号发送出去；接收方还原出帧，再取出分组，通过系统主线交给IP协议实体（主机或路由器）**

![](PIC\184.png)

### 差错检测和纠正

#### CRC

**CRC：循环冗余校验码**

![](PIC\185.png)

**模2运算**，也就是**异或运算**

![](PIC\186.png)

**大致流程**：约定一个**生成多项式G**，传输时数据位加上r位的**EDC（冗余位）**，使得**<u>整体能被生成多项式整除</u>**，以此来确保数据没有出错

![](PIC\187.png)

**利用模2运算（异或）和生成多项式G 推论并求解出<u>*冗余位 R*</u>，然后发送出去**

推导过程：

![](PIC\188.png)

**最后，接收方根据收到的数据能否被约定的<u>生成多项式G</u>整除来判断传输中是否有出错**

**CRC实例**

![](PIC\189.png)

###  多点访问协议

![](PIC\190.png)

2个或更多节点同时传输时会产生冲突

多路访问协议:是分布式算法，来**<u>决定节点是如何使用共享信道的</u>**  

![](PIC\191.png)

**MAC：媒体访问控制协议**

![](PIC\193.png) 

#### 信道划分

**TDMA**：time division multiple access，划分时间片来使用

![](PIC\192.png)

**FDMA**：frequency division multiple access，分频来使用

![](PIC\194.png)

**CDMA**：code division multiple access，码分多路访问

![](PIC\195.png)

随机存取协议：

![](PIC\196.png)

 **时隙ALOHA**

核心：**时间片划分**来发送。如果检测到了冲突，**<u>在下一个时隙以概率p传输直到成功</u>**

![](PIC\197.png)

![](PIC\198.png)

![](PIC\200.png)

**纯ALOHA（非时隙）**

![](PIC\199.png)

#### CSMA

**载波监听多路访问**:发送数据之前监听一下信道，如果有人在的话就不发，直到没人了自己再发送。

**<u>局域网中最远两个节点距离越远，发生冲突的可能性越大</u>**

##### CSMA/CD

CD:边说边听，当**检测到冲突后立刻把传输终止**，减少对信道的浪费

![](PIC\201.png)

算法流程：

![](PIC\202.png)

**二进制指数退避算法：exponential backoff**

是一种**<u>自适应算法</u>**，**对网络中<u>*载荷*</u>自适应**。连续碰撞次数多了之后，再次碰撞概率变小，但等待时间变长

![](PIC\203.png)

![](PIC\204.png)

##### CSMA/CA

**CA**：Collision Avoidance

WLAN构成：**基站，无线链路，移动主机节点**

无线局域网wlan**不做CD（冲突检测）**，不冲突不一定成功，冲突了也不一定不成功，所以做CD没有意义。**<u>另外，自己的接受天线和发送天线离得太近</u>**，收到自己的电磁波信号远超过别的人发送的信号。

![](PIC\205.png)

![](PIC\206.png)

 ![](PIC\207.png)

**线缆接入网络**

![](PIC\208.png)

#### 轮流MAC协议

**轮询机制**：主节点**轮流**询问每个节点有没有要发的数据

可靠性问题：**存在单点故障**。如果master主节点挂了，整个信道就没用了

![](PIC\209.png)

#### 总结

![](PIC\210.png)

### LANs

局域网技术

#### MAC地址

**IP：<u>前n-1跳路由到目标子网（网络号起作用）最后一跳在子网内部路由到目标主机号（主机号来作用）</u>**

**<u>*区别：IP地址是网络层的，MAC地址是链路层的*</u>，ip是<u>便于路由聚集，减少路由表的生成和计算</u>。mac只是封装在网卡内部，<u>唯一标识设备</u>用的**

**ARP协议**：IP地址转到对应的MAC地址

**网卡**是链路层的，路由器发给他**<u>分组和MAC地址</u>**才能封装成帧

![](PIC\211.png)

为什么分离?

![](PIC\212.png)

**局域网内部每个适配器都有一个唯一的LAN地址**

![](PIC\213.png)

> MAC地址也叫物理地址、硬件地址，由网络设备厂家直接烧录在网卡上的，理论上Mac地址是唯一的。但因为Mac地址可以通过程序修改，所以也有可能会重复。
>
> IP地址是互联网上的每台设备都规定了一个唯一的地址，这个地址就叫做“IP地址”。由于有了这个唯一的地址，才能保证用户能够高效地找到自己想要进行通信的设备。
>
> IP地址与MAC地址在计算机里都是以二进制表示的，**IP地址是32位的，而MAC地址则是48位的**。
>
> IP地址通常用“点分十进制”表示成（a.b.c.d）的形式，其中，a,b,c,d都是0~255之间的十进制整数。例：（100.41.53.106）。
>
> MAC地址通常表示为12个16进制数，如：00-16-EA-AE-3C-40就是一个MAC地址，其中前3个字节，16进制数00-16-EA代表网络硬件制造商的编号，它由IEEE(电气与电子工程师协会)分配，而后3个字节，16进制数AE-3C-40代表该制造商所制造的某个网络产品(如网卡)的系列号。全1的是广播地址
>
> 举例来说，**Mac地址就像身份证号一样，具有唯一性，IP就像是你的电话号码可以有多个**

![](PIC\214.png)

#### ARP

![](PIC\215.png)

通过广播地址询问LAN中的所有节点，然后收到目标mac地址的ip地址后，缓存下来**20min**（因为**ip地址和mac地址对应关系 可能换**）

#### 以太网

**<u>最早广泛应用</u>的LAN技术，带宽也在日益增加**

![](PIC\216.png)

**同轴电缆（BUS）**，存在可靠性问题，比如老鼠咬坏线就所有用户都用不了

![](PIC\217.png)

后面由**总线型**进化为**HUB（集线器）**，**每次信号都是全部覆盖，逻辑上还是总线型**。HUB之间也可以级联，在高负载的时候反复碰撞，利用率不高

![](PIC\218.png)

最后升级到**<u>Switch（交换机）</u>**，多个主机可以同时并行地发送和接受

![](PIC\219.png)

前导码：前7个字节的10101010，最后一个字节是10101011，用来**<u>*同步接收方和发送方的时钟频率*</u>**

![](PIC\220.png)

以太网性质：

链路层一般默认是可靠的，不负责可靠性的传输与重传等

![](PIC\221.png)

T代表双绞线，两个导体的截面就小，形成的电势少，线路之间的干扰就小

![](PIC\222.png)

#### Manchester编码

最底层物理层的内容，曼彻斯特编码，**跳变是为了收集时钟信号，然后方向向上或向下跳变代表数据为0和1**

> 曼彻斯特编码(Manchester)又称**裂相码、同步码、相位编码**，是一种用电平跳变来表示1或0的编码方法，其变化规则很简单，即每个码元均用两个不同相位的电平信号表示，也就是一个周期的方波，但0码和1码的相位正好相反。由于曼彻斯特码在每个时钟位都必须有一次变化，因此，其编码的效率仅可达到50%左右

![](PIC\223.png)

![](PIC\224.png)

![](PIC\225.png)

交换机实现多路同时传输，全双工，**<u>只是一个交换设备，从而弱化介入访问控制的功能</u>**

![](PIC\226.png)

实例：

![](PIC\227.png)

流程：每个终端通过**AP**接入，固定的设备接入楼层交换机，楼层交换机级联接入大楼交换机，大楼交换机级联接入校区交换机，校区交换机通过**光纤（虚线为替补光纤，为了可靠性）**接入网络中心**核心交换机**（用**<u>生成树算法</u>避免交换机之间形成环，避免*<u>广播风暴</u>***）

![](PIC\228.png)

#### AP和路由器

> 无线AP也叫无线接入点。从名字上就可以看出它的功能重点在于**<u>无线接入，根本没有路由的功能</u>**。简单点说，它就是一个**“专业无线交换机**”，通常包含如下功能：  
>
> 无线路由器里有的无线功能，AP全部支持。而且安全加密还支持802.1x认证，也就是可以同时需要用户名和密码的认证方式。  功率可调：无线AP的无线发射功率通常是可以调整的，而无线路由器通常是默认的。  
>
> AC集中管控：无线AP中的瘦AP都是通过AC来集中管控的，用户可以通过AC来统一配置所有AP。  
>
> 无缝漫游：由于有AC集中管控的介入，相邻AP之间就可以协同工作，终端在相邻AP之间漫游时，就可以做到无缝漫游。 
>
>  Mesh组网：很多AP都支持无线Mesh组网，也就是AP可以通过无线的方式和相邻的AP构建一张空中的网状网。  
>
> POE供电：这个主要是因为AP安装方式通常是吸顶、壁挂的方式。有了这个POE供电就可以简化取电的难题。

**不同之处**

**使用场合**：

- 无线路由器通常适用于**家庭、SOHO办公环境**。在这种场景下，一般同时上网的人不多，而且上网的人普遍只是简单的上网。对无线网络的稳定性要求也不会太高，如果无线网络出现问题，影响也不会太大。而且一个无线路由器既可以解决上网，又可以解决无线覆盖。
- 无线AP则通常用于**企业单位场景**，在这种场景下，同上上网的人一般比较多，基本都是20人以上。而且上网的需求普遍都是工作或者企业应用。对无线网络的稳定性要求较高，一旦无线网络出现问题，会影响工作。

**性能**：

- 无线路由器的参数重点**体现在<u>路由及NAT方面</u>**，在无线方面的带机量一般也就在3~8台。当然，这里说的区间是无线性能较好的状态，如果继**续增加带机量，无线性能通常会有所下降**。毕竟它的CPU重点要**<u>*处理路由事务*</u>**。
- 无线AP的性能全部是在**<u>*无线接入*</u>**上，它们普遍都可以稳定地带起**20-30台无线终端**。而且还是同时上网的无线终端。无线性能是无线路由器的好几倍。

#### 交换机和路由器

- 都是存储转发设备，都有转发表
- 用途不同：连接的网络种类不同。比如局域网主要是交换机来连接，而外网要用路由器来连接，因为路由器出现时间晚，更具有兼容性，所以也能连接区域网。而一般个人用户对路由器的需求量是不太大的，一般由家庭、公司为单位来使用。
-  功能不同：路由器能串联起来多台电子设备并将IP分配，**使多个主机共同使用一个IP，对外却表现出只有一个IP地址**。交换机的主要功能是可以**把很多主机连起来，这些主机每一个都有自己的IP显示，形成多个ip地址共同工作的场景**。 
- 工作层次不同：路由器和交换机的区别主要还体现在工作时的层次不同，**<u>*交换机工作是在第二层也就是OSI模型的数据链路层。而路由器则是在第三层，工作在OSI模型的网络层*</u>**。主要是因为交换机的原理比路由器较为简单，所以路由器的层级更高，所具有的功能也更广泛。 

### 数据中心网络

![](PIC\230.png)

### 总结

填充码的作用就是把长度较短的帧填充到>2T的持续时间（**T是最远两个节点之间的传输延时**），确保帧的发送是成功的

![](PIC\231.png)

## **第八章 网络安全**

- 机密性
- 可认证性：发送方和接收方确认对方身份
- 报文完整性：**双方确认文件传输中没被改变**
- 访问控制和服务的可用性

![](PIC\232.png)

### 加密原理

- **明文：plaintext**
- **密文：ciphertext**
- **密钥：key**

加密：密钥 + 明文

解密：密钥 + 密文  ——> 明文

对称密钥：加密和解密的**密钥是一样**

公开密钥：发送方**用接收方的公钥加密**，**接收方用自己的私钥解密**

![](PIC\233.png)

#### 对称替换密码

**单码替换**，复杂度是26！，没有计算机的时代是可以暴力破解的

还可以利用**启发式搜索，例如词频**等等来化简

![](PIC\234.png)

![](PIC\235.png)

DES：**US的加密标准**，56位的密钥，64bit成组加密成64bit的密文

**三重DES**更安全，三次加密，更安全

![](PIC\236.png)

**AES：取代DES成为了<u>*新的对称密钥标准*</u>**

**<u>加密强度相比DES增强了非常多</u>**

![](PIC\237.png)

块加密：分成8个块然后乱置

![](PIC\238.png)

![](PIC\239.png)

#### 公开密钥密码

![](PIC\240.png)

##### RSA

**核心**：

1. 寻找两个**大质数p，q**
2. n = pq，z = (p-1)(q-1)
3. 寻找一个**e**和z**互素**
4. 选择d，**使得ed-1能够被z整除**
5. **<u>公钥（n，e），私钥（n，d）</u>**

![](PIC\241.png)

加密/解密过程：

![](PIC\242.png)

**底层数学原理**

**模运算和幂运算顺序可以颠倒**，**<u>*只需要求出e，d 和 n*</u>**

![](PIC\243.png)

![](PIC\244.png)

![](PIC\245.png)

**欧拉函数**

![](PIC\246.png)

![](PIC\247.png)

**模反元素**

![](PIC\248.png)

**<u>n需要很大因为要让最后的m%n = m</u>**

![](PIC\249.png)

![](PIC\250.png)

![](PIC\251.png)

### 密钥分发与证书

![](PIC\252.png)

- **H（m）：报文摘要**
- **KB-：私钥**
- **KB+：公钥**

![](PIC\253.png)

双方建立可靠的通信必须同时**信任<u>第三方可信赖中介</u>**

- **KDC**：对称加密体系的中介
- **CA**: 公开密钥加密的中介

#### KDC

给每个用户分享一个对称式的密钥 

![](PIC\254.png)

KDC加密流程：

KDC会<u>**额外提供一个对称会话密钥R1**</u>，之后A和B就可以共享这个key来交流

![](PIC\255.png)

#### CA

CA用自己的私钥**给每个注册用户创建证书并捆绑实体信息和他的公钥**

**证书 = 实体 + 公钥**

![](PIC\256.png)

邮件安全性

![](PIC\257.png)

### SSL

Secure socket layer 安全套接字

SSL跑在TCP之上，**提供安全传输服务**,加强TCP安全性

**<u>*http和https的区别就是https是在SSL之上，http只是在TCP之上*</u>**

![](PIC\258.png)

SSL的3个阶段：

1. 握手
2. 密钥导出
3. 数据传输

### IPsec

网络层面的安全性，IP层上的安全协议

![](PIC\259.png)

AH

![](PIC\260.png)

ESP

![](PIC\261.png)

### 防火墙

将内网与外网隔离开来，**<u>对进出的分组按照网络管理员的规则起到一个过滤的作用</u>**

![](PIC\262.png)

常用过滤规则：

![](PIC\263.png)

例：

![](PIC\264.png)

#### ACL表

防火墙把分组和ACL表作匹配，执行相应操作，**<u>最后一条是默认规则（全是通配符 ），一般是deny</u>**

<u>会检查**源ip，源端口，目标ip，目标端口**</u>

![](PIC\265.png)

**有状态的分组过滤**

加一个**<u>checkconnection字段（连接建立标志位）</u>**，例如必须和内网设备建立连接起来才能顺利发送

![](PIC\266.png)

![](PIC\267.png)

**Ip spoofing**：可以篡改自己的ip头部字段，以此绕开防火墙

![](PIC\268.png)

## 攻击原理

通常，攻击者使用一个非法账号将DDoS主控程序安装在一台计算机上，并在网络上的多台计算机上安装代理程序。在所设定的时间内，主控程序与大量代理程序进行通讯，代理程序收到指令时对目标发动攻击，主控程序甚至能在几秒钟内激活成百上千次代理程序的运行。

![](PIC\275.png)

### IDS

防火墙会**分析IP，TCP或UDP之类的头部信息来过滤**，**<u>*IDS会分析传输的内部数据，*</u>**

**IDS会匹配massage的字节流，判断是否存在符合<u>病毒特征码</u>，否则就会报警（<u>*IDS只会检测，不会动作*</u>）**

![](PIC\269.png)

![](PIC\270.png)

### 攻击模拟

踩点：**<u>*先ping一下，看看哪些端口是活跃的，判断实现了哪些应用*</u>**

![](PIC\271.png)

### 分组嗅探

**访问者接入内网，对于所有未加密的数据都监听下来，截获所有数据帧，剖析内部传输的内容（早期有很多应用是<u>明文传密码</u>之类，很危险）**

对策：检测软件，周期性**检查网卡是否运行于混杂模式**

> **混杂模式（英语：promiscuous mode）**是电脑网络中的术语。是指**<u>一台机器的网卡能够接收所有经过它的数据流，而不论其目的地址是否是它</u>**。 一般计算机网卡都工作在非混杂模式下，此时网卡只接受来自网络端口的目的地址指向自己的数据。当网卡工作在混杂模式下时，网卡将来自接口的所有数据都捕获并交给相应的驱动程序。网卡的混杂模式一般在**网络管理员分析网络数据作为网络故障诊断手段时**用到，同时这个模式也被**<u>*网络黑客利用来作为网络数据窃听的入口*</u>**。在Linux操作系统中设置网卡混杂模式时需要管理员权限。在Windows操作系统和Linux操作系统中都有**使用混杂模式的抓包工具，比如著名的开源软件Wireshark**。

![](PIC\272.png)

### IP spoofing

**IP地址欺骗**是指行动产生的IP数据包为伪造的源IP地址，以便**冒充其他系统或发件人的身份。这是一种黑客的攻击形式，黑客使用一台计算机上网,而借用另外一台机器的IP地址,从而冒充另外一台机器与服务器打交道**。

**<u>放出去出去的分组被修改源地址，变得不属于这个网段</u>**

对策：入口过滤

![](PIC\273.png)

![](PIC\274.png)

### DOS

**<u>拒绝服务攻击DoS(Denial of Service)</u>**：**使系统过于忙碌而不能执行有用的业务并且占尽关键系统资源**。它是基于这样的思想：用数据包淹没本地系统，以打扰或严重阻止捆绑本地的服务响应外来合法的请求，甚至使本地系统崩溃。实现Dos攻击，常见的方式有：**TCP SYN泛洪**(SYN Flood)，**ping泛洪**(ping-Flood)，**UDP泛洪**(UDP-Flood)，**分片炸弹**(fragmentation bombs)，**缓冲区溢出**(buffer overflow)和**ICMP路由重定向炸弹**(ICMP routeing redirect bomb)

**DDOS**

**本质是分布式的DOS**

**分布式拒绝服务（Distributed Denial of Service，简称DDoS）**将多台计算机联合起来作为攻击平台，通过远程连接，利用恶意程序对一个或多个目标发起DDoS攻击，**<u>消耗目标服务器性能或网络带宽</u>**，从而造成服务器无法正常地提供服务。

# **第九章 软件定义网络**

展望**第三代网络，未来网络架构**

> 　**Web3.0（第三代互联网）**区别于Web1.0（第一代互联网）、Web2.0（第二代互联网）的核心特征是，**它是以用户为中心的可信的价值互联网，是智能的立体全息互联网，能极大提升用户体验。**
>
> 　　这是一场数据变革，数据的所有权和身份的自主权将从大型平台回归于用户，互联网将变得更加平等、更加开放、更加符合群体利益。在Web2.0中，大量的用户数据集中于互联网平台，一旦泄露，将对用户隐私造成极大损害，比如Facebook（脸书）就发生过类似事件。在Web3.0中，用户数据经密码算法保护后存储在分布式系统中。身份信息与谁共享、数据是何用途均由用户决定。一个典型的商业案例是自动分布式信用评分系统，链上智能合约会先检索与每个钱包相关的所有交易信息，再输入机器学习模型，最后得到用户的征信评分。只有客户签名之后的征信报告才能被各方使用，以有效防止数据和征信报告被滥用。
>
> 　　这是一场信任变革，信息互联网将演化为可信的价值互联网。Web1.0和Web2.0仅是信息网络，虽然可以传播文字、图片、声音、视频等信息，但无法像发邮件、发短信一样点对点传递价值。**<u>Web3.0则是价值互联网，不需要依赖特定中介机构即可实现价值的点对点传递。最典型的Web3.0的商业应用是数字货币，比如USDT（泰达币）。在互联网中传递价值的形式还可以是数字资产，这两年的热点是NFT（非同质化通证）。NFT起先在卡通和游戏领域试水，后来艺术家、拍卖行、数字媒体、文化公司、体育联盟纷纷向NFT注入各类文化IP（知名文创作品），使得数字文化、数字藏品通过NFT可在网上直接流转。</u>**

![](PIC\276.png)

![](PIC\277.png)

## SDN

原因：现有**网络僵化**，不灵活。因为**交换机和路由器是<u>封闭的系统，专用的硬件上构建专用的操作系统，应用固化在硬件上，无法扩展</u>**

![](PIC\278.png)

核心思想：**将操作系统分离出来，构建统一的操作系统。在这个操作系统之上，<u>将应用解耦出来，支持科研和企业在上面做创新，简化交换机和路由器（只需要做简单的报文转发）</u>**

![](PIC\279.png)

![](PIC\280.png)

举例：

![](PIC\281.png)

## NDN

**命名数据网络**

![282](PIC\282.png)

今天的互联网是**以主机，ip为中心，会导致网络流量重复**

## TCP/IP架构存在的问题

TCP/IP互联网只提供一个通讯**管道**，**<u>只负责维护管道，不关心传输的内容</u>**。内容的管理和获取是有应用和服务管理的。

存在哪些问题呢：

1. **效率低**。管道是单源单路径的，容易造成拥塞，比如**同一个视频，要从单个服务器发送无数次。**
2. **可扩展性差**。不断打补丁，网络设计管理越来越复杂。IP地址也不够用了。
3. **安全性弱**。重视管道保护，但不能保证数据本身的可靠性。比如建立一个信任连接后，对方发的恶意代码也会照收无误。

NDN网络企图用**数据内容**取代管道的核心地位。

**核心思想**：

**<u>命名驱动</u>**

1. **用户程序只提供数据的名字，无需目的地址；**
2. **数据可以来自任何节点；（不用都从服务器拿数据，可以从就近的缓存获取）**
3. **每个数据包必须有数字签名；（保证安全可靠）**

**优势：**

1. **高效**。（多源多路径，组播发送，有缓存）
2. **无需建立管道连接**，适合现代场景如移动互联网、物联网、灾害救援、时延容忍网络(DTN）等。（
3. **安全**。（数据有签名，需要时可加密；应用程序开发时就考虑数据安全，而非事后弥补）

### NDN与IP架构的区别

- IP数据包：**核心字段是地址**；NDN数据包：分为兴趣包和数据包两种类型，不包含地址，**核心是名字**。

  

![](PIC\283.png)

![](PIC\284.png)

![](PIC\285.png)

NDN**打破了端到端的传输模式，中间结点有的话直接就传回**

### 报文

![](PIC\286.png)

**<u>数据消费者发送兴趣包，数据节点或生产者沿着兴趣包的报文路径发回数据包</u>**

**TLV基本格式**

![](PIC\287.png)

- **待定兴趣表 PIT** ： **存储兴趣包请求，维护进出端口**
- **转发信息表 FIB**：**实现名字和端口的映射，指导兴趣包转发（类似路由）**
- 内容存储 CS：缓存数据，方便查询

![](PIC\291.png)

**转发流程概述**

![](PIC\292.png)

**兴趣包查询步骤：**
CS：是否已经有缓存了；
PIT：是否已经有其他人请求过了，那就不用再重复发请求了，只需记录一下，在包回来时给所有请求都分一份就行；
FIB：查询哪条路径能满足请求，把兴趣包转发下去。

**数据包，查询步骤：**
PIT：若有该数据的请求，发给所有请求列表；若无则直接丢弃。
CS：留一份缓存后，继续转发。

## NDN路由机制

### 命名驱动

1. 服务端注册名字。数据发布者需要注册一个名字前缀（name prefix），比如YouTube注册了一个YouTube/……
2. **路由器根据名字建表。路由器能计算出到达每个名字前缀的路径，建立起路由表**。
3. 用户端拿名字请求数据。数据消费者发送兴趣包来请求数据，路由器根据名字和路由表匹配转发。

### 路由缓存

**每个节点都可以缓存数据，可以被反复请求使用**。

**用户的请求的数据包是没有收货地址的**，那快递回来后给谁呢？是这么解决的：每个路由器都维护一个**兴趣包缓存表（PIT, Pending Interest Table）**，就像是淘宝订单，谁请求过什么数据都记录在案！路由器能根据兴趣包缓存表，将数据反向传输给请求者。

### 路由转发

**IP数据包路由转发。缺点有：**

1. 单向的。（请求可能有去无回）
2. 路由器是无状态的。（太笨）
3. 不会缓存任何数据。（太慢）

**NDN兴趣包和数据包的转发。优势是：**

1. 双向的。（有请求才有数据，二者一一对应）
2. 有状态的。（路由器记录多种状态，信息量大）
3. 有缓存。

## 移动优先网络

![](PIC\293.png)

移动优先核心思想：**名字与地址分离，在网络中只要提供<u>*名字和地址的动态映射*（类似DNS中的域名和ip）</u>**

![](PIC\294.png)

![](PIC\295.png)

### 存储感知抗毁路由

因为**<u>*逐跳确认的性质*</u>，跳不通的时候会停下来保存在本地，然后终端切换后GUID和网络地址更新后，继续重新传输。不需要源端断续重传，网络内部就可以实现路由传输了，具有了存储感知抗毁性。**

![](PIC\297.png)

# 习题

## 第一章

1.

![](PIC\298.png)

传播时延（管道中传送的时间）：m/s

传输时延（数据推送到网络中所要的时间）：L/R

![](PIC\299.png)

2.

![](PIC\300.png)

![](PIC\301.png)

**利用几何分布的期望和方差公式分别是E(n)等于1/p、方差等于(1-p)/p**

3.

![](PIC\320.png)

![](PIC\321.png)

4.

![](PIC\322.png)

答：优点是**<u>线路交换为端到端预留了带宽资源，保证带宽</u>**

TDM需要更复杂一点硬件，信号需要加载到不同的**载波**上，然后到**<u>多路复用时用一条线路传输</u>**

5.

![](PIC\323.png)

答：吞吐量就是有效带宽的最小值

![](PIC\324.png)

6.

![](PIC\325.png)

**应用层：借助传输层协议交换报文，实现各种应用**

**传输层：加强网络层的服务，提供多路复用，可靠性等性质**

**网络层：主机到主机，端到端的数据转发和路由**

**链路层：完成相邻两点的以帧为单位的传输**

**物理层： 物理介质上加载和还原数字信号**

7.

![](PIC\326.png)

**<u>路由器：三层设备</u>，处理的是<u>网络层，链路层，物理层</u>**

**链路层交换机：链路层，物理层**

**主机：所有层次**

8.

![](PIC\327.png)

![](PIC\328.png)

9.

![](PIC\329.png)

a.**线路交换应该更适合，因为需要的带宽是比较恒定的，分配一个线路带宽，只要小于这个带宽就不会排队**

10.

![](PIC\330.png)

![](PIC\331.png)

**设X = L/R，X越趋近于1/a（即流量强度I越接近于1的时候），t = 传输时间+排队延时 趋近于无穷大**

![](PIC\332.png)

11.

**带宽—时延积 = 传播延时 * 带宽，**意义就是**<u>表示整个链路同时能容纳的最多 bit位</u>**

![](PIC\333.png)

![](PIC\334.png)

12.

![](PIC\335.png)



## 第二章

1.

![](PIC\302.png)

2.

![](PIC\303.png)

 3.

![](PIC\304.png)

![](PIC\305.png)

![](PIC\306.png)

4.

![](PIC\336.png)

![](PIC\337.png)

![](PIC\338.png)

**并行和串行的差别很小，因为带宽太小了**

![](PIC\339.png)

> **N小的时候，瓶颈在客户端（服务器提供的比客户端接受的快很多）**
>
> **N大的时候，均分了带宽，瓶颈在服务器**

**C-S模式**：

![](PIC\340.png)

**P2P模式**：

![](PIC\341.png)

## 第三章

1.

![](PIC\307.png)

![308](PIC\308.png)

2.

**<u>注意三个冗余ACK是阈值变为一半，cwnd变为 一半 + 3，超时是cwnd直接变为1</u>**

![](PIC\309.png)

![](PIC\310.png)

![](PIC\311.png)

3.

![](PIC\312.png)

![313](PIC\313.png)

4.

![](PIC\342.png)

rdt引入序号是为了**区分数据包是重传还是新数据，也可以判断数据包顺序是否正确**

引入定时器是为了**防止丢包；发送方发送分组后启动定时器，如果定时器结束前未收到ACK，则重传，防止丢包现象**

5.

![]( PIC\343.png)

6.

![](PIC\344.png)

7.

![](PIC\345.png)

- **a.110-90 = 20bytes**
- **b.90。收到89后，没收到90，<u>ACK为顺序收到的最后的一个字节+1，即为期望收到的字节号**</u>**

8.

![](PIC\346.png)

9.

![](PIC\347.png)

## 第四章

1.

![](PIC\314.png)

2.

![](PIC\315.png)

3.

![](PIC\316.png)

4.

![](PIC\353.png)

5.

![](PIC\354.png)

6.

**MTU**指的是**<u>某个物理网络的最大载荷</u>**

![](PIC\355.png)

## 第五章

1.

![](PIC\317.png)

2.

![](PIC\318.png)

3.

![](PIC\356.png)

4.

**LS和DV算法的比较**

![](PIC\357.png)

![358](PIC\358.png)

## 第六章

1.

![](PIC\319.png)

2.

TCP数据包可能通过不同的路由来传送，而且IP也可能丢失数据包

![](PIC\359.png)

3.

![](PIC\360.png)

4.

ARP在一个子网内**广播式请求，单播式应答**

**任何一个网卡独立拥有一个MAC地址**

![](PIC\361.png)

5.

![](PIC\362.png)

6.

![](PIC\363.png)

1. 发出DHCP查询，DHCP发回**ip地址，子网掩码，名字服务器代理，默认网关等等**
2. DNS。浏览器输入域名，向本地域名服务器查询，如果有的话直接返回，否则他去向顶级域的域名服务器查询。获得**域名和ip的对应关系**
3. 根据子网掩码判断出不在一个子网，**ARP查询出子网内出口路由器端口的MAC和ip地址对应关系**。然后封装TCP的连接请求建立的段，封装成IP分组，网卡封装成帧，发给出口路由器，它查询路由表后转发出去，最后服务器接受请求后发回所需要的数据。
4. 收到Web对象后，链接渲染在浏览器上就呈现出所需网页了。
