# 编译原理

编译：**将预处理过后的C语言代码转换为汇编代码.c文件**

## 编译(compile) 

1. **利用编译程序从源语言编写的源程序产生目标程序的过程。** 
2. 用编译程序产生目标程序的动作。 编译就是把高级语言变成计算机可以识别的2进制语言，计算机只认识1和0，编译程序把人们熟悉的语言换成2进制的。 

​		编译程序把一个源程序翻译成目标程序的工作过程分为五个阶段：

- **词法分析**
- **语法分析**
- **语义检查和中间代码生成**
- **代码优化**
- **目标代码生成**

![](pic\77.png)

​		主要是进行**词法分析和语法分析**，又称为源程序分析，分析过程中发现有语法错误，给出提示信息。

​		编译语言是一种以编译器来实现的编程语言。它不像直译语言一样，由解释器将代码一句一句运行，而是以**编译器**，**<u>先将代码编译为机器码，再加以运行</u>**。理论上，任何编程语言都可以是编译式，或直译式的。它们之间的区别，仅与程序的应用有关。

![](PIC\0.png)

![](PIC\1.png)

**解释程序**：**不需要进行全文的转换，碰到一条解释一条**，例如**Python** 和 **Matlab**，UNIX命令语言**shell**

**编译程序**：进行全文的转换，生成低级设计语言程序，例如**C和C++**

![](PIC\2.png)

![](PIC\3.png)

**词法分析**：输入源程序，**对构成源程序的字符串进行扫描和分解**，识别出**单词符号**，工具为<u>**有限自动机**</u>

**语法分析**：在词法分析的基础上，依据**语法规则**将单词符号串分解为**语法单位**，工具为**<u>上下文无关文法</u>**

**中间代码生成**：对各类**语法单位**按语言 的语义进行**初步翻译**，工具为**<u><u>属性文法</u>/u>**

**代码优化**：对中间代码进行加工变换，**产生更高效的目标代码**

 **目标代码生成**：把中间代码变换为**特定机器上的目标代码**

1. 汇编指令代码：需要汇编器进行汇编，变成机器指令代码
2. 绝对指令代码：可直接运行
3. 可重定位指令代码：需要链接

**错误处理**

![](pic\78.png)

**标识符是语法概念，名字是语义概念**

## 语法

**一组规则，用它可以形成一个合适的程序**

### 词法规则

**单词符号**的形成规则。单词符号是语言中具有独立意义的**最基本结构**，包括**常数，标识符，基本字，算符**等等

描述工具：**有限自动机**

### 语法规则

**语法单位**的形成规则。语法单位通常包括：**表达式，语句，分程序，过程，函数**等等

描述工具：**上下文无关文法**

### 语义规则

可以定义一个程序的意义，描述方法是自然语言描述，形式描述

## 语法描述

闭包和正规闭包，区别是**如果V中有空字，则闭包中必包含空字，而正规闭包中则没有**。

## 语法树

![](PIC\4.png)

**节点代表操作，子节点就是操作数，当前的结果作为父节点的操作数。**  

## 形式语言

![](pic\5.png)

**语言**：给定字母表，任意的一个串的集合

**子序**列：给定串中的若干个字符删掉**（不一定连续）**

## 上下文无关文法

一个四元组

![](pic\79.png)

![](pic\6.png)

![](pic\7.png)

不规定开始符号的话，G的产生式的第一个左边符号就定位**开始符号**

## 句型与句子

![](pic\83.png)

![](pic\8.png)

句子和句型的**区别**：**句子**从开始符号出发推导出的，且X必须是**空串或由终结符构成的串（即仅含终结符号的句型是一个句子）**

**两个文法等价**：两个文法产生的语言是相同的

![](pic\9.png)

0型文法:左边只要不是**空串**

1型文法：**上下文有关**

![](pic\10.png)

2型文法：**上下文无关**

![](pic\11.png)

3型文法：**正则文法**

![](pic\12.png)

![](pic\13.png)

**文法与识别系统**

![](pic\14.png)

### 句型与推导

![](pic\60.png)

![](pic\15.png)

**规范推导**：也就是**最右**推导

![](pic\16.png)

## 推导树

**语法树**表示**一个句型的推导**

![](pic\17.png)

如果语法树**无二义性**，则一定有**唯一的最左/右推导**

**文法是二义的 不代表 语法是二义的**

文法中**存在某个句子对应两棵不同的语法树，则说这个文法是二义的**

![](pic\18.png)

### 树的构造

两种方法：自上而下和自下而上

![](pic\19.png)

![]()![20](pic\20.png)

![](pic\21.png)

## 正规集和正规式

![](pic\80.png)

![](pic\81.png)

## 词法分析器

作用：**识别并分类出token**

![](pic\22.png)

![](pic\23.png)

![](pic\24.png)

![](pic\25.png)

### token

token的定义是借助**<u>正则定义</u>**

![](pic\26.png)

## DFA

五元组：**有限集合，有穷字母表，映射关系，初始状态，终止状态**

![](pic\52.png)

## NFA

**区别**

1. NFA中的M是一个**多值映射**，而DFA是单值映射；
2. NFA输入的是符号串，DFA输入的是符号；
3. NFA可能有**空转换ε标识**，DFA没有ε标识；	
4. NFA初始状态不唯一，DFA的是唯一的	

> 对于字母表中的每个符号，DFA中的每个状态都有且只有一条关于这个符号的出边（exiting transition）。NFA则未必，在同一个状态上可能有零条、一条甚至多条关于某一个符号的出边。DFA的转换箭头上的标签必须是字母表中的，但NFA可以有标识为ϵ \epsilonϵ的边，NFA的状态可能有零条、一条甚至多条ϵ \epsilonϵ边。

![](pic\27.png)

### DFA和NFA转换 

也叫NFA确定化

![](pic\53.png)

![](pic\82.png)

NFA允许**空转换**

![](pic\28.png)

![](pic\29.png)

![](pic\30.png)

**一个正规式r与一个有限自动机（DFA和NFA）M等价**

## 语法分析

![](pic\84.png)

### 上下文无关文法

用来**描述语法规则**

一个**四元式**：终结符集合，非终结符集合，开始符号，产生式集合

### 自下而上分析

**算符优先文法，LR分析法**

![](pic\85.png)

### 自上向下分析

**递归下降分析法，预测分析程序**

![](pic\31.png)

每一步推导得到**文法的一个句型，直到产生出一个句子**

**<u>两类不确定性</u>**：选哪个**非终结符**，非终结符中选哪个**产生式**

![](pic\32.png)

通常要求文法不含**左公因子**，带来分析时的不确定性，需要消除左公因子

可以通过**文法变换**消除左公因子

## LL1文法

### 判定

![](pic\89.png)

![](pic\50.png)

L：从左扫苗

L：最左推导

1：表示分析时每一步只需向前查看一个符号

![](pic\33.png)

### FIrst集合

![](pic\34.png)

![](pic\35.png)

First (X) 由**从X可能推导出的所有终结符号串的开头终结符**组成，此外可能还有**ε**

现在为任意串a = X1 X2 . . . Xn （终结符和非终结符的串）定义First (a)，如下所示：First (a)包括First (X1) 对于每个i = 2, . . . , n ，如果对于所有的k = 1, . . . ,i -1 ，First (Xk) 包括了ε，则First (a)就包括了First (Xi)。**最后，如果对于所有的i =1, . . . , n ，First (Xi) 都包括了ε，则First (a)也包括了ε。**

例题：

![](pic\36.png)

### Follow集合

**Follow 集合**的意思就是求**<u>`非终结符右边所有终结符的集合`</u>**，follow集合里不能有空

![](pic\49.png)

![](pic\37.png)

### 定义

![](pic\39.png)

### 性质   

![](pic\40.png)

![](pic\90.png)

### 非LL1文法到LL1文法的等价变换

#### **1.提取左公因子**

![](pic\88.png)

![](pic\43.png)

![](pic\44.png)

#### **2.消除左递归**

其实是左递归变为**右递归**

##### 直接左递归消除

![](pic\86.png)

![](pic\45.png)

![](pic\46.png)

##### 间接左递归消除

变成直接左递归然后消除

![](pic\87.png)

### 递归下降分析

类似**DFS（深度优先搜索）**

代码示例：

![](pic\41.png)

局限性是左公因子，左递归

可以**解析任何上下文无关文法，但不适用于左递归文法**

![](pic\91.png)

![](pic\92.png)

### 预测分析

依然是一个**自上而下**的解析器，但能够预测该使用哪个产生式。接受LL（k）语法

提取左公因子：消除一个非终结符多个产生式的公共前缀

#### 预测分析表

利用First集和Follow集来构建LL（1）表

![](pic\93.png)

![](pic\42.png)

例：

![](pic\140.png)

输入是终结符，栈顶都是非终结符

> 如果解析表中任何一个单元格被**多重定义**，那么这个语法就**不是LL（1）语法**

LL（1）文法太弱，大部分编程语言都不使用这个文法分析

如果文法是左递归或者二义的话，M**至少有一个多重定义入口**。**<u>不含多重定义入口当且仅当该文法是LL1文法</u>**

## 自底向上分析

> **自顶向下**的语法分析会采用**最左推导**方式
>
> **自底向上**的语法分析采用**最左归约**方式（反向构造**最右推导**）

自下而上解析器会**逆序追踪一个最右推导**

![](pic\47.png)

### 算符优先分析

![](pic\94.png)

![](pic\95.png)

只考虑终结符之间的优先关系

没有形如A-》BC的产生式就称为算符文法 

算符优先分析法,它**<u>虽然是一种自下而上的语法分析方法,但它并不是一种规范归约的分析方法</u>**。这是因为在算符优先文法中,仅在终结符号之间定义优先关系而未对非终结符定义优先关系,从而无法使用优先关系表去识别由单个非终结符组成的可归约串,也就是说,算符优先分析法不是用句柄来刻画可归约串,而是用**<u>最左素短语</u>**来刻画可归约串的。

**素短语是指这样一种短语,它至少包含一个终结符,并且除自身之外,不再包含其他的素短语**

#### FIRSTVT和LASTVT

![](pic\96.png)

![](C:\CHARLES\Senior\汇编与编译原理\编译原理\pic\51.png)

##### 构造算法

![](pic\97.png)

![](pic\98.png)

![](pic\48.png)

### 短语

短语：一个句型的语法树种任一子树的叶节点所组成的符号串都是该句型的短语

直接短语：一个句型的语法树种任一最小子树的叶节点所组成的符号串

**素短语**：高度为2的树的叶节点是一个素短语

句柄：最左素短语

![](pic\99.png)

### LR0分析模型

一种**表驱动的移进归约分析** 

**<u>LR0文法不存在移进-归约冲突和归约-归约冲突</u>**

#### 项集

![](pic\61.png)

![](pic\54.png)

![](pic\55.png)

![](pic\56.png)

#### 增广文法

![](pic\57.png)

​		引入这个新的开始产生式的目的是使得文法开始符号仅出现在一个产生式的左边，从而使得分析器只有一个接受状态。（简单的理解:**如果原文法中初始状态，比如上例中的E，可以推导出不止一个式子，那么就是说明接收状态不止一个，对于自动分析不利**，所以我们需要加**<u>上一个新产生式，使得初始状态只能有一个推导式</u>**，也就是说这个初始符号，在式子的左边只可以出现一次！）

![](pic\59.png)

#### 分析步骤

1. 先判断是否需要利用增广文法

2. 当下一个输入字符是S的时候，从I0中可以发现S’–> **·** S符合下一个输入字符是S。所以S可以入栈，形成I1：S’–>S **·**

3. **当圆点后面是非终结符**，我们就需要重新对这个非终结符进行展开，重新读取。类似I0的形成，只要圆点出现在推导式中**右边第一个位置**即可。类似的可以看看例子中I3的形成。

4. 得到一个DFA图（上图中间橙色框框组成的部分），构造出一个LR(0)分析表

   

   > 由I1:S’–>S **·** ，我们可以知道运算到这里就成功，所以（1，$）==acc
   >
   > <u>**I4已经是归约项目了，无论下一个输入什么字符，都采取归约操作。通过文法发现，I4中的B–>b ·**</u>
   > <u>**对应于文法中的（3）B–>b,所以（4，a/b/$）==r3 ( r:归约 3：文法中第三个式子),这里归约的时候，不用看后面GOTO，因为GOTO中填的只能是数字</u>**

**识别活前缀的DFA**

等价于**构造<u>项集规范族</u>: 状态 	项目集	后继符号 	后继状态**	

![](pic\135.png)

### SLR1

![](pic\100.png)

**解决LR0不能处理的移进-归约冲突和归约-归约冲突**

对于**有冲突的项目集才向前查看一个符号**进行处理以解决冲突，是<u>**简单的LR1分析法**</u>

**<u>通过Follow集解决冲突</u>**

![](pic\62.png) 

### LR1

增加了**展望符**集合

![](pic\63.png)

### LALR

减少LR1带来的过多状态数

![](pic\64.png)

### 二义文法

用**优先性和结合性**的来解决冲突

### LR分析中的错误处理

### 语法制导翻译

#### 定义

![](pic\65.png)

语法制导翻译是使用CFG来引导对语言的翻译，是一种面向文法的翻译技术

![66](pic\66.png)

![](pic\67.png)

![](pic\75.png)

#### 语法树

**S-属性文法**

![](pic\76.png)

#### 依赖图

依赖图描述了分析树种结点属性之间依赖关系的有向图

![](pic\68.png)

### S属性和L属性

**<u>S属性是L属性的第一个特例</u>**

**S属性：**

仅仅使用**综合属性**的SDD，所有属性值都是通过子节点的属性值来定义的

可以按照自底向上的顺序计算它的各个属性值，可以**在自底向上的语法分析过程中实现**

 **L属性：**

在一个产生式所关联的各个属性之间，依赖图的边可以从左到右，但不能从右到左。

**L属性可以采用自顶向下深度优先从左到右遍历树的方法来计算所有的属性值**

L属性SDD当且仅当每个属性都是一个综合属性或者不能形成环路

![](pic\69.png)

**<u>每个S属性定义都是一个L属性定义</u>**

![](pic\72.png)

### 语法制导翻译方案SDT

![](pic\70.png)

**SDT可以看成SDD的具体实施方案**

#### S-SDD转换为SDT

**将每个语义动作都放在产生式的最后**

![](pic\71.png)  

![](pic\73.png)

根据产生式右边的符号属性来定义

![](pic\74.png)

### 建立翻译模式

![101](pic\101.png)

## 中间语言

**高级语言和低级语言之间的过渡作用**![102](pic\102.png)

## 符号表

作用：

1. 登记各类名字的信息
2. 编译各个阶段都需要使用符号表

符号表每一项包含**两大栏目**

![](pic\103.png)

**常用操作**

![](pic\104.png)

符号表的存放

![](pic\105.png)

**符号表的整理和查找**

- **线性查找**

![](pic\106.png)

- **二分查找**

![](pic\107.png)

- **杂凑查找（HASH查找）**

![108](pic\108.png)

![](pic\109.png)

## 运行时存储组成

### 过程的活动生存期

![](pic\110.png)

### 运行时存储器划分

![](pic\111.png)

# 期末复习

## 第二章 编译基础知识

编译程序：输入数据时**源程序**，输出为**目标程序**

![](pic\77.png)

词法规则：规定字母表中**哪些字符串是单词符号**            常数，标识符，基本字，算符，界限符

语法规则：规定了**如何从单词符号来形成语法单位**			表达式，子句，语句，函数，过程，程序

**<u>语法  =  词法规则 + 语法规则</u>**

语言：由S开始通过1到多步构成的**句子**的集合

**句型：可以从开始符号推导出来的符号串**

**句子：仅由终结符号组成的句型**

![](pic\112.png)

**文法**：定义为四元组：**非终结符集，终结符集，产生式，开始符号或识别符号**

**两个文法等价**：两个文法产生的语言是相同的

文法的类型：

![](pic\113.png)

![](pic\126.png)

**推导**

规范推导是**最右推导**

![](pic\114.png)

语法树

![](pic\115.png)

文法的**二义性**：

如果一个文法**存在某个句子对应两棵不同的语法树**，则说这个文法是二义的
若一个文法中**存在某个句子，它有两个不同的最左（最右）推导**，则这个文法是二义的

## 第三章 词法分析

语法分析的任务：**识别句子** 根据产生式识别输入串是否为一个句子
自顶向下语法分析受**上下文无关文法**影响

自上而下语法分析器，从文法的开始符号出发，反复使用文法的产生式，建立与输入符号串匹配**最左推导**

仅有字母表上的**正规式a**所组成的语言称为**正规集**，记为**L（a）**

**DFA**

五元组：**有限状态集合，有穷字母表，映射关系，唯一的初始状态，可空终止状态**

**NFA**

五元组：**有限状态集合，有穷字母表，映射关系，非空的初始状态（可能有多个初态），可空终止状态**

**区别**

1. NFA中的M是一个**多值映射**，而DFA是单值映射；
2. NFA输入的是符号串，DFA输入的是符号；
3. NFA可能有**空转换ε标识**，DFA没有ε标识；	
4. NFA初始状态可以不唯一，DFA的是唯一的	

NFA和DFA的转换

## 第四章 自上而下语法分析

自上而下语法分析：**推导**	预测分析程序，**递归下降分析法**

自下而上语法分析：**归约**	简单优先分析法，**算符优先分析法，LR分析法**

**LL1文法**

**<u>1.消除左递归</u>**

**消除直接左递归**

![](pic\116.png)

**消除间接左递归（代入法）**

![](pic\117.png)

例：

![](pic\118.png)

![119](pic\119.png)

![](pic\120.png)

**First集合：**

对于不含左递归的文法，每个候选的**终结首符号集**叫做FIRST集合

![](pic\121.png)

非终结符A的FIRST集两两不相交

**提取公共左因子**

![](pic\123.png)

**Follow集合：**

![](pic\124.png)

**LL1文法构造每个非终结符的FIRST集合和FOLLOW集合**

![](pic\127.png)

## 第五章 自底向上优先分析

![](pic\128.png)

**算符优先文法：**

扩展算符文法 -> FIRSTVT集合 -> LASTVT集合 -> 算符优先表 -> 分析过程

## 第六章 LR分析

L指代**自左向右**扫描，**R代表最右推导的逆过程**

分析表构造方法：**LR（0)分析表构造法、SLR分析表构造法、LR（1）分析表构造法，LALR**

- 动作表 **ACTION**   **终结符 + #**
- 转向表 **GOTO**      **非终结符**
- 分析表符号:**S:将读入符号a移入栈内并转到j状态；R：按照相应产生式归约**

LR0构造过程

**SLR**是LR0的一种改进，**消除了归约-归约冲突，但不能解决移进-归约冲突**

因为只对有冲突的状态才向前查看一个符号，所以也叫**简单LR1分析法**

SLR（1）：简单的LR(1)文法。不带向前搜索符，**为了解决LR(0)中移进-规约冲突和规约-规约冲突。**

SLR(1)的使用条件

SLR(1)只能用于存在移进-规约冲突和规约-规约冲突的文法中**对应的FOLLOW集合交集**为空。

![](pic\129.png)

**LR1**在每个LR0项目**添加展望信息**，即添加句柄之后可能跟着的终结符

为了解决SLR(1)中的问题，我们用**向前搜索符代替follow集合的做法**。因此产生了LR(1)。

缺点：**分析表可能会异常大，难以进行分析**

![](pic\130.png)

**LALR1**在**LR1的文法基础**上构造的**简化的，具有预测能力**的分析方法为了解决LR(1)冗余的问题，**针对<u>同心集的合成</u>后依然不会产生冲突**，说明该文法是LALR(1)的文法。

**分析能力比LR1弱，比SLR强**，**分析表尺寸与SLR相同**

**二义性**

![](pic\131.png)

**判断文法是否二义的步骤**：

1. 构造LR1分析表
2. 合并为LALR分析表
3. 填满归约后判断有无冲突
4. SLR能否解决冲突

## 第七章 语法制导翻译并产生中间代码

**中间代码**：不同硬件有不同的指令系统，**高级语言与低级语言之间的过渡，不是机器语言但便于生成机器语言**

形式为**四元式，三元式，后缀表达式/逆波兰表达式**

为文法符号关联有特定意义的属性，并**为产生式关联相应的语义动作或条件谓词，称为属性文法**

**四元式**

格式：**运算符   运算对象  运算对象  临时变量**

![](pic\138.png)

**抽象语法树**

![](pic\136.png)

逆波兰式不需要括号，两种计算技巧：栈或直接写

![](pic\137.png)

![](pic\139.png)

## 第八章 运行时数据区的管理

运行时存储管理方案主要分为两大类：**静态存储分配**和**动态存储分配**

动态存储分配：有**递归调用**和**可变数组**

![](pic\132.png)

## 第九章 代码优化

**代码优化的目的**：**提高目标代码的运行效率**：**运行时间较短，占用空间较少**

代码优化的实质：实际上**是对代码进行<u>等价变换**</u>，由一组代码变成运行结果相同的另一组代码

## 简答题

### 1.编译程序和高级语言有什么区别？

答：用**汇编语言或高级语言**写的源程序必须**编译**后转换为**机器语言表述的目标程序**后才能由计算机执行。

**汇编语言：没有编译过的汇编语言源文件**

**编译语言：一种以编译器来实现的编程语言。它不像直译语言一样，由解释器将代码一句一句运行，而是以编译器，<u>先将代码编译为机器码，再加以运行</u>****

编译程序分为三种：**汇编型，解释型和编译型**。

**解释程序**：**不需要进行全文的转换，碰到一条解释一条**，例如**Python** 和 **Matlab**，UNIX命令语言**shell**

**编译程序**：进行全文的转换，生成低级设计语言程序，例如**C，C++和FORTRAN**

### 2.编译程序工作分为几个阶段？

答：**词法分析，语法分析，中间代码生成，代码优化，目标代码生成**

### 3.简述自下而上的分析方法

答：从输入串开始，逐步进行**归约**，直至归约到文法的开始符号。或者说从语法树的末端开始一步一步向上**归约**，直到根节点

![](pic\134.png)

### 4.简述代码优化的目的和意义

答：对程序代码进行**等价变换**，保证变换前后代码的执行结果相同的前提下，**尽量使目标程序运行时所需要的时间更短，同时占用的存储空间更小。**

### 5.如何证明一个文法是二义的？

答：一个文法，如果**存在某个句子有不止一棵语法分析树生成**，那么称这个文法为二义性文法

![](pic\133.png)